// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uranium.proto

#ifndef PROTOBUF_uranium_2eproto__INCLUDED
#define PROTOBUF_uranium_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace uranium {
namespace api {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_uranium_2eproto();
void protobuf_AssignDesc_uranium_2eproto();
void protobuf_ShutdownFile_uranium_2eproto();

class Field;
class FieldValue;
class HashExistsRequest;
class HashExistsResponse;
class HashGetAllFieldsRequest;
class HashGetAllFieldsResponse;
class HashGetAllRequest;
class HashGetAllResponse;
class HashGetAllValuesRequest;
class HashGetAllValuesResponse;
class HashGetRequest;
class HashGetResponse;
class HashLengthRequest;
class HashLengthResponse;
class HashRemoveAllRequest;
class HashRemoveAllResponse;
class HashRemoveRequest;
class HashRemoveResponse;
class HashSetRequest;
class HashSetResponse;
class HashSetXRequest;
class HashSetXResponse;
class KVGetRequest;
class KVGetResponse;
class KVRemoveRequest;
class KVRemoveResponse;
class KVSetRequest;
class KVSetResponse;
class Key;
class KeyValue;
class ListIndexRequest;
class ListIndexResponse;
class ListLPopRequest;
class ListLPopResponse;
class ListLPushRequest;
class ListLPushResponse;
class ListLPushXRequest;
class ListLPushXResponse;
class ListLengthRequest;
class ListLengthResponse;
class ListRPopRequest;
class ListRPopResponse;
class ListRPushRequest;
class ListRPushResponse;
class ListRPushXRequest;
class ListRPushXResponse;
class ListRangeRequest;
class ListRangeResponse;
class ListRemoveAllRequest;
class ListRemoveAllResponse;
class ListSetRequest;
class ListSetResponse;
class SetAddRequest;
class SetAddResponse;
class SetGetAllRequest;
class SetGetAllResponse;
class SetIsMemberRequest;
class SetIsMemberResponse;
class SetLengthRequest;
class SetLengthResponse;
class SetRemoveAllRequest;
class SetRemoveAllResponse;
class SetRemoveRequest;
class SetRemoveResponse;
class Value;

// ===================================================================

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();

  Key(const Key& from);

  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();

  void Swap(Key* other);

  // implements Message ----------------------------------------------

  inline Key* New() const { return New(NULL); }

  Key* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Key* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:uranium.api.Key)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  inline Value* New() const { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:uranium.api.Value)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static Value* default_instance_;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  void Swap(KeyValue* other);

  // implements Message ----------------------------------------------

  inline KeyValue* New() const { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.api.Key key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional .uranium.api.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Key* key_;
  ::uranium::api::Value* value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  inline Field* New() const { return New(NULL); }

  Field* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes field = 1;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::std::string& field() const;
  void set_field(const ::std::string& value);
  void set_field(const char* value);
  void set_field(const void* value, size_t size);
  ::std::string* mutable_field();
  ::std::string* release_field();
  void set_allocated_field(::std::string* field);

  // @@protoc_insertion_point(class_scope:uranium.api.Field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr field_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class FieldValue : public ::google::protobuf::Message {
 public:
  FieldValue();
  virtual ~FieldValue();

  FieldValue(const FieldValue& from);

  inline FieldValue& operator=(const FieldValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldValue& default_instance();

  void Swap(FieldValue* other);

  // implements Message ----------------------------------------------

  inline FieldValue* New() const { return New(NULL); }

  FieldValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FieldValue& from);
  void MergeFrom(const FieldValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FieldValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.api.Field key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::uranium::api::Field& key() const;
  ::uranium::api::Field* mutable_key();
  ::uranium::api::Field* release_key();
  void set_allocated_key(::uranium::api::Field* key);

  // optional .uranium.api.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.FieldValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Field* key_;
  ::uranium::api::Value* value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static FieldValue* default_instance_;
};
// -------------------------------------------------------------------

class KVGetRequest : public ::google::protobuf::Message {
 public:
  KVGetRequest();
  virtual ~KVGetRequest();

  KVGetRequest(const KVGetRequest& from);

  inline KVGetRequest& operator=(const KVGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVGetRequest& default_instance();

  void Swap(KVGetRequest* other);

  // implements Message ----------------------------------------------

  inline KVGetRequest* New() const { return New(NULL); }

  KVGetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVGetRequest& from);
  void MergeFrom(const KVGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // repeated .uranium.api.Key keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::uranium::api::Key& keys(int index) const;
  ::uranium::api::Key* mutable_keys(int index);
  ::uranium::api::Key* add_keys();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >&
      keys() const;

  // @@protoc_insertion_point(class_scope:uranium.api.KVGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Key > keys_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class KVGetResponse : public ::google::protobuf::Message {
 public:
  KVGetResponse();
  virtual ~KVGetResponse();

  KVGetResponse(const KVGetResponse& from);

  inline KVGetResponse& operator=(const KVGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVGetResponse& default_instance();

  void Swap(KVGetResponse* other);

  // implements Message ----------------------------------------------

  inline KVGetResponse* New() const { return New(NULL); }

  KVGetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVGetResponse& from);
  void MergeFrom(const KVGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.KeyValue kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::uranium::api::KeyValue& kvs(int index) const;
  ::uranium::api::KeyValue* mutable_kvs(int index);
  ::uranium::api::KeyValue* add_kvs();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >*
      mutable_kvs();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >&
      kvs() const;

  // @@protoc_insertion_point(class_scope:uranium.api.KVGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue > kvs_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class KVSetRequest : public ::google::protobuf::Message {
 public:
  KVSetRequest();
  virtual ~KVSetRequest();

  KVSetRequest(const KVSetRequest& from);

  inline KVSetRequest& operator=(const KVSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVSetRequest& default_instance();

  void Swap(KVSetRequest* other);

  // implements Message ----------------------------------------------

  inline KVSetRequest* New() const { return New(NULL); }

  KVSetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVSetRequest& from);
  void MergeFrom(const KVSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // repeated .uranium.api.KeyValue kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  const ::uranium::api::KeyValue& kvs(int index) const;
  ::uranium::api::KeyValue* mutable_kvs(int index);
  ::uranium::api::KeyValue* add_kvs();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >*
      mutable_kvs();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >&
      kvs() const;

  // @@protoc_insertion_point(class_scope:uranium.api.KVSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue > kvs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class KVSetResponse : public ::google::protobuf::Message {
 public:
  KVSetResponse();
  virtual ~KVSetResponse();

  KVSetResponse(const KVSetResponse& from);

  inline KVSetResponse& operator=(const KVSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVSetResponse& default_instance();

  void Swap(KVSetResponse* other);

  // implements Message ----------------------------------------------

  inline KVSetResponse* New() const { return New(NULL); }

  KVSetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVSetResponse& from);
  void MergeFrom(const KVSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.KVSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class KVRemoveRequest : public ::google::protobuf::Message {
 public:
  KVRemoveRequest();
  virtual ~KVRemoveRequest();

  KVRemoveRequest(const KVRemoveRequest& from);

  inline KVRemoveRequest& operator=(const KVRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVRemoveRequest& default_instance();

  void Swap(KVRemoveRequest* other);

  // implements Message ----------------------------------------------

  inline KVRemoveRequest* New() const { return New(NULL); }

  KVRemoveRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVRemoveRequest& from);
  void MergeFrom(const KVRemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVRemoveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // repeated .uranium.api.Key keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::uranium::api::Key& keys(int index) const;
  ::uranium::api::Key* mutable_keys(int index);
  ::uranium::api::Key* add_keys();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >*
      mutable_keys();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >&
      keys() const;

  // @@protoc_insertion_point(class_scope:uranium.api.KVRemoveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Key > keys_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVRemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class KVRemoveResponse : public ::google::protobuf::Message {
 public:
  KVRemoveResponse();
  virtual ~KVRemoveResponse();

  KVRemoveResponse(const KVRemoveResponse& from);

  inline KVRemoveResponse& operator=(const KVRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVRemoveResponse& default_instance();

  void Swap(KVRemoveResponse* other);

  // implements Message ----------------------------------------------

  inline KVRemoveResponse* New() const { return New(NULL); }

  KVRemoveResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KVRemoveResponse& from);
  void MergeFrom(const KVRemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KVRemoveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.KVRemoveResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static KVRemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListLPushRequest : public ::google::protobuf::Message {
 public:
  ListLPushRequest();
  virtual ~ListLPushRequest();

  ListLPushRequest(const ListLPushRequest& from);

  inline ListLPushRequest& operator=(const ListLPushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPushRequest& default_instance();

  void Swap(ListLPushRequest* other);

  // implements Message ----------------------------------------------

  inline ListLPushRequest* New() const { return New(NULL); }

  ListLPushRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPushRequest& from);
  void MergeFrom(const ListLPushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPushRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPushRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListLPushResponse : public ::google::protobuf::Message {
 public:
  ListLPushResponse();
  virtual ~ListLPushResponse();

  ListLPushResponse(const ListLPushResponse& from);

  inline ListLPushResponse& operator=(const ListLPushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPushResponse& default_instance();

  void Swap(ListLPushResponse* other);

  // implements Message ----------------------------------------------

  inline ListLPushResponse* New() const { return New(NULL); }

  ListLPushResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPushResponse& from);
  void MergeFrom(const ListLPushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPushResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPushResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPushResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListLPopRequest : public ::google::protobuf::Message {
 public:
  ListLPopRequest();
  virtual ~ListLPopRequest();

  ListLPopRequest(const ListLPopRequest& from);

  inline ListLPopRequest& operator=(const ListLPopRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPopRequest& default_instance();

  void Swap(ListLPopRequest* other);

  // implements Message ----------------------------------------------

  inline ListLPopRequest* New() const { return New(NULL); }

  ListLPopRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPopRequest& from);
  void MergeFrom(const ListLPopRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPopRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPopRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPopRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListLPopResponse : public ::google::protobuf::Message {
 public:
  ListLPopResponse();
  virtual ~ListLPopResponse();

  ListLPopResponse(const ListLPopResponse& from);

  inline ListLPopResponse& operator=(const ListLPopResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPopResponse& default_instance();

  void Swap(ListLPopResponse* other);

  // implements Message ----------------------------------------------

  inline ListLPopResponse* New() const { return New(NULL); }

  ListLPopResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPopResponse& from);
  void MergeFrom(const ListLPopResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPopResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional .uranium.api.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPopResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Value* value_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPopResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRPushRequest : public ::google::protobuf::Message {
 public:
  ListRPushRequest();
  virtual ~ListRPushRequest();

  ListRPushRequest(const ListRPushRequest& from);

  inline ListRPushRequest& operator=(const ListRPushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPushRequest& default_instance();

  void Swap(ListRPushRequest* other);

  // implements Message ----------------------------------------------

  inline ListRPushRequest* New() const { return New(NULL); }

  ListRPushRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPushRequest& from);
  void MergeFrom(const ListRPushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPushRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPushRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListRPushResponse : public ::google::protobuf::Message {
 public:
  ListRPushResponse();
  virtual ~ListRPushResponse();

  ListRPushResponse(const ListRPushResponse& from);

  inline ListRPushResponse& operator=(const ListRPushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPushResponse& default_instance();

  void Swap(ListRPushResponse* other);

  // implements Message ----------------------------------------------

  inline ListRPushResponse* New() const { return New(NULL); }

  ListRPushResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPushResponse& from);
  void MergeFrom(const ListRPushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPushResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPushResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPushResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRPopRequest : public ::google::protobuf::Message {
 public:
  ListRPopRequest();
  virtual ~ListRPopRequest();

  ListRPopRequest(const ListRPopRequest& from);

  inline ListRPopRequest& operator=(const ListRPopRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPopRequest& default_instance();

  void Swap(ListRPopRequest* other);

  // implements Message ----------------------------------------------

  inline ListRPopRequest* New() const { return New(NULL); }

  ListRPopRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPopRequest& from);
  void MergeFrom(const ListRPopRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPopRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPopRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPopRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListRPopResponse : public ::google::protobuf::Message {
 public:
  ListRPopResponse();
  virtual ~ListRPopResponse();

  ListRPopResponse(const ListRPopResponse& from);

  inline ListRPopResponse& operator=(const ListRPopResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPopResponse& default_instance();

  void Swap(ListRPopResponse* other);

  // implements Message ----------------------------------------------

  inline ListRPopResponse* New() const { return New(NULL); }

  ListRPopResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPopResponse& from);
  void MergeFrom(const ListRPopResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPopResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional .uranium.api.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPopResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Value* value_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPopResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListLPushXRequest : public ::google::protobuf::Message {
 public:
  ListLPushXRequest();
  virtual ~ListLPushXRequest();

  ListLPushXRequest(const ListLPushXRequest& from);

  inline ListLPushXRequest& operator=(const ListLPushXRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPushXRequest& default_instance();

  void Swap(ListLPushXRequest* other);

  // implements Message ----------------------------------------------

  inline ListLPushXRequest* New() const { return New(NULL); }

  ListLPushXRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPushXRequest& from);
  void MergeFrom(const ListLPushXRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPushXRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPushXRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPushXRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListLPushXResponse : public ::google::protobuf::Message {
 public:
  ListLPushXResponse();
  virtual ~ListLPushXResponse();

  ListLPushXResponse(const ListLPushXResponse& from);

  inline ListLPushXResponse& operator=(const ListLPushXResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLPushXResponse& default_instance();

  void Swap(ListLPushXResponse* other);

  // implements Message ----------------------------------------------

  inline ListLPushXResponse* New() const { return New(NULL); }

  ListLPushXResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLPushXResponse& from);
  void MergeFrom(const ListLPushXResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLPushXResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLPushXResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLPushXResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRPushXRequest : public ::google::protobuf::Message {
 public:
  ListRPushXRequest();
  virtual ~ListRPushXRequest();

  ListRPushXRequest(const ListRPushXRequest& from);

  inline ListRPushXRequest& operator=(const ListRPushXRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPushXRequest& default_instance();

  void Swap(ListRPushXRequest* other);

  // implements Message ----------------------------------------------

  inline ListRPushXRequest* New() const { return New(NULL); }

  ListRPushXRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPushXRequest& from);
  void MergeFrom(const ListRPushXRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPushXRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPushXRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPushXRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListRPushXResponse : public ::google::protobuf::Message {
 public:
  ListRPushXResponse();
  virtual ~ListRPushXResponse();

  ListRPushXResponse(const ListRPushXResponse& from);

  inline ListRPushXResponse& operator=(const ListRPushXResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRPushXResponse& default_instance();

  void Swap(ListRPushXResponse* other);

  // implements Message ----------------------------------------------

  inline ListRPushXResponse* New() const { return New(NULL); }

  ListRPushXResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRPushXResponse& from);
  void MergeFrom(const ListRPushXResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRPushXResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRPushXResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRPushXResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListIndexRequest : public ::google::protobuf::Message {
 public:
  ListIndexRequest();
  virtual ~ListIndexRequest();

  ListIndexRequest(const ListIndexRequest& from);

  inline ListIndexRequest& operator=(const ListIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListIndexRequest& default_instance();

  void Swap(ListIndexRequest* other);

  // implements Message ----------------------------------------------

  inline ListIndexRequest* New() const { return New(NULL); }

  ListIndexRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListIndexRequest& from);
  void MergeFrom(const ListIndexRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListIndexRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional int64 index = 3;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListIndexRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::int64 index_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListIndexRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListIndexResponse : public ::google::protobuf::Message {
 public:
  ListIndexResponse();
  virtual ~ListIndexResponse();

  ListIndexResponse(const ListIndexResponse& from);

  inline ListIndexResponse& operator=(const ListIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListIndexResponse& default_instance();

  void Swap(ListIndexResponse* other);

  // implements Message ----------------------------------------------

  inline ListIndexResponse* New() const { return New(NULL); }

  ListIndexResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListIndexResponse& from);
  void MergeFrom(const ListIndexResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListIndexResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional .uranium.api.Value value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListIndexResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Value* value_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListIndexResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListSetRequest : public ::google::protobuf::Message {
 public:
  ListSetRequest();
  virtual ~ListSetRequest();

  ListSetRequest(const ListSetRequest& from);

  inline ListSetRequest& operator=(const ListSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSetRequest& default_instance();

  void Swap(ListSetRequest* other);

  // implements Message ----------------------------------------------

  inline ListSetRequest* New() const { return New(NULL); }

  ListSetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSetRequest& from);
  void MergeFrom(const ListSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional int64 index = 3;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // optional .uranium.api.Value value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::int64 index_;
  ::uranium::api::Value* value_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListSetResponse : public ::google::protobuf::Message {
 public:
  ListSetResponse();
  virtual ~ListSetResponse();

  ListSetResponse(const ListSetResponse& from);

  inline ListSetResponse& operator=(const ListSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListSetResponse& default_instance();

  void Swap(ListSetResponse* other);

  // implements Message ----------------------------------------------

  inline ListSetResponse* New() const { return New(NULL); }

  ListSetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListSetResponse& from);
  void MergeFrom(const ListSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRangeRequest : public ::google::protobuf::Message {
 public:
  ListRangeRequest();
  virtual ~ListRangeRequest();

  ListRangeRequest(const ListRangeRequest& from);

  inline ListRangeRequest& operator=(const ListRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRangeRequest& default_instance();

  void Swap(ListRangeRequest* other);

  // implements Message ----------------------------------------------

  inline ListRangeRequest* New() const { return New(NULL); }

  ListRangeRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRangeRequest& from);
  void MergeFrom(const ListRangeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional int64 start = 3;
  void clear_start();
  static const int kStartFieldNumber = 3;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // optional int64 end = 4;
  void clear_end();
  static const int kEndFieldNumber = 4;
  ::google::protobuf::int64 end() const;
  void set_end(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 end_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRangeRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListRangeResponse : public ::google::protobuf::Message {
 public:
  ListRangeResponse();
  virtual ~ListRangeResponse();

  ListRangeResponse(const ListRangeResponse& from);

  inline ListRangeResponse& operator=(const ListRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRangeResponse& default_instance();

  void Swap(ListRangeResponse* other);

  // implements Message ----------------------------------------------

  inline ListRangeResponse* New() const { return New(NULL); }

  ListRangeResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRangeResponse& from);
  void MergeFrom(const ListRangeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.Value values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.ListRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRangeResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListLengthRequest : public ::google::protobuf::Message {
 public:
  ListLengthRequest();
  virtual ~ListLengthRequest();

  ListLengthRequest(const ListLengthRequest& from);

  inline ListLengthRequest& operator=(const ListLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLengthRequest& default_instance();

  void Swap(ListLengthRequest* other);

  // implements Message ----------------------------------------------

  inline ListLengthRequest* New() const { return New(NULL); }

  ListLengthRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLengthRequest& from);
  void MergeFrom(const ListLengthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLengthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLengthRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLengthRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListLengthResponse : public ::google::protobuf::Message {
 public:
  ListLengthResponse();
  virtual ~ListLengthResponse();

  ListLengthResponse(const ListLengthResponse& from);

  inline ListLengthResponse& operator=(const ListLengthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListLengthResponse& default_instance();

  void Swap(ListLengthResponse* other);

  // implements Message ----------------------------------------------

  inline ListLengthResponse* New() const { return New(NULL); }

  ListLengthResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListLengthResponse& from);
  void MergeFrom(const ListLengthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListLengthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional int64 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListLengthResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 length_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListLengthResponse* default_instance_;
};
// -------------------------------------------------------------------

class ListRemoveAllRequest : public ::google::protobuf::Message {
 public:
  ListRemoveAllRequest();
  virtual ~ListRemoveAllRequest();

  ListRemoveAllRequest(const ListRemoveAllRequest& from);

  inline ListRemoveAllRequest& operator=(const ListRemoveAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRemoveAllRequest& default_instance();

  void Swap(ListRemoveAllRequest* other);

  // implements Message ----------------------------------------------

  inline ListRemoveAllRequest* New() const { return New(NULL); }

  ListRemoveAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRemoveAllRequest& from);
  void MergeFrom(const ListRemoveAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRemoveAllRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRemoveAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRemoveAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListRemoveAllResponse : public ::google::protobuf::Message {
 public:
  ListRemoveAllResponse();
  virtual ~ListRemoveAllResponse();

  ListRemoveAllResponse(const ListRemoveAllResponse& from);

  inline ListRemoveAllResponse& operator=(const ListRemoveAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRemoveAllResponse& default_instance();

  void Swap(ListRemoveAllResponse* other);

  // implements Message ----------------------------------------------

  inline ListRemoveAllResponse* New() const { return New(NULL); }

  ListRemoveAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRemoveAllResponse& from);
  void MergeFrom(const ListRemoveAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRemoveAllResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.ListRemoveAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static ListRemoveAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashGetRequest : public ::google::protobuf::Message {
 public:
  HashGetRequest();
  virtual ~HashGetRequest();

  HashGetRequest(const HashGetRequest& from);

  inline HashGetRequest& operator=(const HashGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetRequest& default_instance();

  void Swap(HashGetRequest* other);

  // implements Message ----------------------------------------------

  inline HashGetRequest* New() const { return New(NULL); }

  HashGetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetRequest& from);
  void MergeFrom(const HashGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  const ::uranium::api::Field& fields(int index) const;
  ::uranium::api::Field* mutable_fields(int index);
  ::uranium::api::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
      fields() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field > fields_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashGetResponse : public ::google::protobuf::Message {
 public:
  HashGetResponse();
  virtual ~HashGetResponse();

  HashGetResponse(const HashGetResponse& from);

  inline HashGetResponse& operator=(const HashGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetResponse& default_instance();

  void Swap(HashGetResponse* other);

  // implements Message ----------------------------------------------

  inline HashGetResponse* New() const { return New(NULL); }

  HashGetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetResponse& from);
  void MergeFrom(const HashGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.FieldValue fvs = 2;
  int fvs_size() const;
  void clear_fvs();
  static const int kFvsFieldNumber = 2;
  const ::uranium::api::FieldValue& fvs(int index) const;
  ::uranium::api::FieldValue* mutable_fvs(int index);
  ::uranium::api::FieldValue* add_fvs();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
      mutable_fvs();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
      fvs() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue > fvs_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllRequest : public ::google::protobuf::Message {
 public:
  HashGetAllRequest();
  virtual ~HashGetAllRequest();

  HashGetAllRequest(const HashGetAllRequest& from);

  inline HashGetAllRequest& operator=(const HashGetAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllRequest& default_instance();

  void Swap(HashGetAllRequest* other);

  // implements Message ----------------------------------------------

  inline HashGetAllRequest* New() const { return New(NULL); }

  HashGetAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllRequest& from);
  void MergeFrom(const HashGetAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllResponse : public ::google::protobuf::Message {
 public:
  HashGetAllResponse();
  virtual ~HashGetAllResponse();

  HashGetAllResponse(const HashGetAllResponse& from);

  inline HashGetAllResponse& operator=(const HashGetAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllResponse& default_instance();

  void Swap(HashGetAllResponse* other);

  // implements Message ----------------------------------------------

  inline HashGetAllResponse* New() const { return New(NULL); }

  HashGetAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllResponse& from);
  void MergeFrom(const HashGetAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.FieldValue fvs = 2;
  int fvs_size() const;
  void clear_fvs();
  static const int kFvsFieldNumber = 2;
  const ::uranium::api::FieldValue& fvs(int index) const;
  ::uranium::api::FieldValue* mutable_fvs(int index);
  ::uranium::api::FieldValue* add_fvs();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
      mutable_fvs();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
      fvs() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue > fvs_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllFieldsRequest : public ::google::protobuf::Message {
 public:
  HashGetAllFieldsRequest();
  virtual ~HashGetAllFieldsRequest();

  HashGetAllFieldsRequest(const HashGetAllFieldsRequest& from);

  inline HashGetAllFieldsRequest& operator=(const HashGetAllFieldsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllFieldsRequest& default_instance();

  void Swap(HashGetAllFieldsRequest* other);

  // implements Message ----------------------------------------------

  inline HashGetAllFieldsRequest* New() const { return New(NULL); }

  HashGetAllFieldsRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllFieldsRequest& from);
  void MergeFrom(const HashGetAllFieldsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllFieldsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllFieldsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllFieldsRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllFieldsResponse : public ::google::protobuf::Message {
 public:
  HashGetAllFieldsResponse();
  virtual ~HashGetAllFieldsResponse();

  HashGetAllFieldsResponse(const HashGetAllFieldsResponse& from);

  inline HashGetAllFieldsResponse& operator=(const HashGetAllFieldsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllFieldsResponse& default_instance();

  void Swap(HashGetAllFieldsResponse* other);

  // implements Message ----------------------------------------------

  inline HashGetAllFieldsResponse* New() const { return New(NULL); }

  HashGetAllFieldsResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllFieldsResponse& from);
  void MergeFrom(const HashGetAllFieldsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllFieldsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.Field fields = 2;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 2;
  const ::uranium::api::Field& fields(int index) const;
  ::uranium::api::Field* mutable_fields(int index);
  ::uranium::api::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
      fields() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllFieldsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field > fields_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllFieldsResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllValuesRequest : public ::google::protobuf::Message {
 public:
  HashGetAllValuesRequest();
  virtual ~HashGetAllValuesRequest();

  HashGetAllValuesRequest(const HashGetAllValuesRequest& from);

  inline HashGetAllValuesRequest& operator=(const HashGetAllValuesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllValuesRequest& default_instance();

  void Swap(HashGetAllValuesRequest* other);

  // implements Message ----------------------------------------------

  inline HashGetAllValuesRequest* New() const { return New(NULL); }

  HashGetAllValuesRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllValuesRequest& from);
  void MergeFrom(const HashGetAllValuesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllValuesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllValuesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllValuesRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashGetAllValuesResponse : public ::google::protobuf::Message {
 public:
  HashGetAllValuesResponse();
  virtual ~HashGetAllValuesResponse();

  HashGetAllValuesResponse(const HashGetAllValuesResponse& from);

  inline HashGetAllValuesResponse& operator=(const HashGetAllValuesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashGetAllValuesResponse& default_instance();

  void Swap(HashGetAllValuesResponse* other);

  // implements Message ----------------------------------------------

  inline HashGetAllValuesResponse* New() const { return New(NULL); }

  HashGetAllValuesResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashGetAllValuesResponse& from);
  void MergeFrom(const HashGetAllValuesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashGetAllValuesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.Value values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashGetAllValuesResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashGetAllValuesResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashLengthRequest : public ::google::protobuf::Message {
 public:
  HashLengthRequest();
  virtual ~HashLengthRequest();

  HashLengthRequest(const HashLengthRequest& from);

  inline HashLengthRequest& operator=(const HashLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashLengthRequest& default_instance();

  void Swap(HashLengthRequest* other);

  // implements Message ----------------------------------------------

  inline HashLengthRequest* New() const { return New(NULL); }

  HashLengthRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashLengthRequest& from);
  void MergeFrom(const HashLengthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashLengthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.HashLengthRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashLengthRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashLengthResponse : public ::google::protobuf::Message {
 public:
  HashLengthResponse();
  virtual ~HashLengthResponse();

  HashLengthResponse(const HashLengthResponse& from);

  inline HashLengthResponse& operator=(const HashLengthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashLengthResponse& default_instance();

  void Swap(HashLengthResponse* other);

  // implements Message ----------------------------------------------

  inline HashLengthResponse* New() const { return New(NULL); }

  HashLengthResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashLengthResponse& from);
  void MergeFrom(const HashLengthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashLengthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional int64 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashLengthResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 length_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashLengthResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashSetRequest : public ::google::protobuf::Message {
 public:
  HashSetRequest();
  virtual ~HashSetRequest();

  HashSetRequest(const HashSetRequest& from);

  inline HashSetRequest& operator=(const HashSetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashSetRequest& default_instance();

  void Swap(HashSetRequest* other);

  // implements Message ----------------------------------------------

  inline HashSetRequest* New() const { return New(NULL); }

  HashSetRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashSetRequest& from);
  void MergeFrom(const HashSetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashSetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.FieldValue fvs = 3;
  int fvs_size() const;
  void clear_fvs();
  static const int kFvsFieldNumber = 3;
  const ::uranium::api::FieldValue& fvs(int index) const;
  ::uranium::api::FieldValue* mutable_fvs(int index);
  ::uranium::api::FieldValue* add_fvs();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
      mutable_fvs();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
      fvs() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashSetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue > fvs_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashSetRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashSetResponse : public ::google::protobuf::Message {
 public:
  HashSetResponse();
  virtual ~HashSetResponse();

  HashSetResponse(const HashSetResponse& from);

  inline HashSetResponse& operator=(const HashSetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashSetResponse& default_instance();

  void Swap(HashSetResponse* other);

  // implements Message ----------------------------------------------

  inline HashSetResponse* New() const { return New(NULL); }

  HashSetResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashSetResponse& from);
  void MergeFrom(const HashSetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashSetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashSetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashSetResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashSetXRequest : public ::google::protobuf::Message {
 public:
  HashSetXRequest();
  virtual ~HashSetXRequest();

  HashSetXRequest(const HashSetXRequest& from);

  inline HashSetXRequest& operator=(const HashSetXRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashSetXRequest& default_instance();

  void Swap(HashSetXRequest* other);

  // implements Message ----------------------------------------------

  inline HashSetXRequest* New() const { return New(NULL); }

  HashSetXRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashSetXRequest& from);
  void MergeFrom(const HashSetXRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashSetXRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional .uranium.api.FieldValue fv = 3;
  bool has_fv() const;
  void clear_fv();
  static const int kFvFieldNumber = 3;
  const ::uranium::api::FieldValue& fv() const;
  ::uranium::api::FieldValue* mutable_fv();
  ::uranium::api::FieldValue* release_fv();
  void set_allocated_fv(::uranium::api::FieldValue* fv);

  // @@protoc_insertion_point(class_scope:uranium.api.HashSetXRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::uranium::api::FieldValue* fv_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashSetXRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashSetXResponse : public ::google::protobuf::Message {
 public:
  HashSetXResponse();
  virtual ~HashSetXResponse();

  HashSetXResponse(const HashSetXResponse& from);

  inline HashSetXResponse& operator=(const HashSetXResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashSetXResponse& default_instance();

  void Swap(HashSetXResponse* other);

  // implements Message ----------------------------------------------

  inline HashSetXResponse* New() const { return New(NULL); }

  HashSetXResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashSetXResponse& from);
  void MergeFrom(const HashSetXResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashSetXResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashSetXResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashSetXResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashRemoveRequest : public ::google::protobuf::Message {
 public:
  HashRemoveRequest();
  virtual ~HashRemoveRequest();

  HashRemoveRequest(const HashRemoveRequest& from);

  inline HashRemoveRequest& operator=(const HashRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashRemoveRequest& default_instance();

  void Swap(HashRemoveRequest* other);

  // implements Message ----------------------------------------------

  inline HashRemoveRequest* New() const { return New(NULL); }

  HashRemoveRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashRemoveRequest& from);
  void MergeFrom(const HashRemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashRemoveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Field fields = 3;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 3;
  const ::uranium::api::Field& fields(int index) const;
  ::uranium::api::Field* mutable_fields(int index);
  ::uranium::api::Field* add_fields();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
      mutable_fields();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
      fields() const;

  // @@protoc_insertion_point(class_scope:uranium.api.HashRemoveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Field > fields_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashRemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashRemoveResponse : public ::google::protobuf::Message {
 public:
  HashRemoveResponse();
  virtual ~HashRemoveResponse();

  HashRemoveResponse(const HashRemoveResponse& from);

  inline HashRemoveResponse& operator=(const HashRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashRemoveResponse& default_instance();

  void Swap(HashRemoveResponse* other);

  // implements Message ----------------------------------------------

  inline HashRemoveResponse* New() const { return New(NULL); }

  HashRemoveResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashRemoveResponse& from);
  void MergeFrom(const HashRemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashRemoveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashRemoveResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashRemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashExistsRequest : public ::google::protobuf::Message {
 public:
  HashExistsRequest();
  virtual ~HashExistsRequest();

  HashExistsRequest(const HashExistsRequest& from);

  inline HashExistsRequest& operator=(const HashExistsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashExistsRequest& default_instance();

  void Swap(HashExistsRequest* other);

  // implements Message ----------------------------------------------

  inline HashExistsRequest* New() const { return New(NULL); }

  HashExistsRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashExistsRequest& from);
  void MergeFrom(const HashExistsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashExistsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional .uranium.api.Field field = 3;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 3;
  const ::uranium::api::Field& field() const;
  ::uranium::api::Field* mutable_field();
  ::uranium::api::Field* release_field();
  void set_allocated_field(::uranium::api::Field* field);

  // @@protoc_insertion_point(class_scope:uranium.api.HashExistsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::uranium::api::Field* field_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashExistsRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashExistsResponse : public ::google::protobuf::Message {
 public:
  HashExistsResponse();
  virtual ~HashExistsResponse();

  HashExistsResponse(const HashExistsResponse& from);

  inline HashExistsResponse& operator=(const HashExistsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashExistsResponse& default_instance();

  void Swap(HashExistsResponse* other);

  // implements Message ----------------------------------------------

  inline HashExistsResponse* New() const { return New(NULL); }

  HashExistsResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashExistsResponse& from);
  void MergeFrom(const HashExistsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashExistsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional bool exists = 2;
  void clear_exists();
  static const int kExistsFieldNumber = 2;
  bool exists() const;
  void set_exists(bool value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashExistsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  bool exists_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashExistsResponse* default_instance_;
};
// -------------------------------------------------------------------

class HashRemoveAllRequest : public ::google::protobuf::Message {
 public:
  HashRemoveAllRequest();
  virtual ~HashRemoveAllRequest();

  HashRemoveAllRequest(const HashRemoveAllRequest& from);

  inline HashRemoveAllRequest& operator=(const HashRemoveAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashRemoveAllRequest& default_instance();

  void Swap(HashRemoveAllRequest* other);

  // implements Message ----------------------------------------------

  inline HashRemoveAllRequest* New() const { return New(NULL); }

  HashRemoveAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashRemoveAllRequest& from);
  void MergeFrom(const HashRemoveAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashRemoveAllRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.HashRemoveAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashRemoveAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class HashRemoveAllResponse : public ::google::protobuf::Message {
 public:
  HashRemoveAllResponse();
  virtual ~HashRemoveAllResponse();

  HashRemoveAllResponse(const HashRemoveAllResponse& from);

  inline HashRemoveAllResponse& operator=(const HashRemoveAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HashRemoveAllResponse& default_instance();

  void Swap(HashRemoveAllResponse* other);

  // implements Message ----------------------------------------------

  inline HashRemoveAllResponse* New() const { return New(NULL); }

  HashRemoveAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HashRemoveAllResponse& from);
  void MergeFrom(const HashRemoveAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HashRemoveAllResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.HashRemoveAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static HashRemoveAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetAddRequest : public ::google::protobuf::Message {
 public:
  SetAddRequest();
  virtual ~SetAddRequest();

  SetAddRequest(const SetAddRequest& from);

  inline SetAddRequest& operator=(const SetAddRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAddRequest& default_instance();

  void Swap(SetAddRequest* other);

  // implements Message ----------------------------------------------

  inline SetAddRequest* New() const { return New(NULL); }

  SetAddRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAddRequest& from);
  void MergeFrom(const SetAddRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetAddRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.SetAddRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetAddRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetAddResponse : public ::google::protobuf::Message {
 public:
  SetAddResponse();
  virtual ~SetAddResponse();

  SetAddResponse(const SetAddResponse& from);

  inline SetAddResponse& operator=(const SetAddResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetAddResponse& default_instance();

  void Swap(SetAddResponse* other);

  // implements Message ----------------------------------------------

  inline SetAddResponse* New() const { return New(NULL); }

  SetAddResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetAddResponse& from);
  void MergeFrom(const SetAddResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetAddResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetAddResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetAddResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetLengthRequest : public ::google::protobuf::Message {
 public:
  SetLengthRequest();
  virtual ~SetLengthRequest();

  SetLengthRequest(const SetLengthRequest& from);

  inline SetLengthRequest& operator=(const SetLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLengthRequest& default_instance();

  void Swap(SetLengthRequest* other);

  // implements Message ----------------------------------------------

  inline SetLengthRequest* New() const { return New(NULL); }

  SetLengthRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLengthRequest& from);
  void MergeFrom(const SetLengthRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetLengthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.SetLengthRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetLengthRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetLengthResponse : public ::google::protobuf::Message {
 public:
  SetLengthResponse();
  virtual ~SetLengthResponse();

  SetLengthResponse(const SetLengthResponse& from);

  inline SetLengthResponse& operator=(const SetLengthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLengthResponse& default_instance();

  void Swap(SetLengthResponse* other);

  // implements Message ----------------------------------------------

  inline SetLengthResponse* New() const { return New(NULL); }

  SetLengthResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLengthResponse& from);
  void MergeFrom(const SetLengthResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetLengthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional int64 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetLengthResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 length_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetLengthResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetIsMemberRequest : public ::google::protobuf::Message {
 public:
  SetIsMemberRequest();
  virtual ~SetIsMemberRequest();

  SetIsMemberRequest(const SetIsMemberRequest& from);

  inline SetIsMemberRequest& operator=(const SetIsMemberRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetIsMemberRequest& default_instance();

  void Swap(SetIsMemberRequest* other);

  // implements Message ----------------------------------------------

  inline SetIsMemberRequest* New() const { return New(NULL); }

  SetIsMemberRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetIsMemberRequest& from);
  void MergeFrom(const SetIsMemberRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetIsMemberRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // optional .uranium.api.Value value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::uranium::api::Value& value() const;
  ::uranium::api::Value* mutable_value();
  ::uranium::api::Value* release_value();
  void set_allocated_value(::uranium::api::Value* value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetIsMemberRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::api::Key* key_;
  ::uranium::api::Value* value_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetIsMemberRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetIsMemberResponse : public ::google::protobuf::Message {
 public:
  SetIsMemberResponse();
  virtual ~SetIsMemberResponse();

  SetIsMemberResponse(const SetIsMemberResponse& from);

  inline SetIsMemberResponse& operator=(const SetIsMemberResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetIsMemberResponse& default_instance();

  void Swap(SetIsMemberResponse* other);

  // implements Message ----------------------------------------------

  inline SetIsMemberResponse* New() const { return New(NULL); }

  SetIsMemberResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetIsMemberResponse& from);
  void MergeFrom(const SetIsMemberResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetIsMemberResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // optional bool yes = 2;
  void clear_yes();
  static const int kYesFieldNumber = 2;
  bool yes() const;
  void set_yes(bool value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetIsMemberResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  bool yes_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetIsMemberResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetGetAllRequest : public ::google::protobuf::Message {
 public:
  SetGetAllRequest();
  virtual ~SetGetAllRequest();

  SetGetAllRequest(const SetGetAllRequest& from);

  inline SetGetAllRequest& operator=(const SetGetAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetGetAllRequest& default_instance();

  void Swap(SetGetAllRequest* other);

  // implements Message ----------------------------------------------

  inline SetGetAllRequest* New() const { return New(NULL); }

  SetGetAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetGetAllRequest& from);
  void MergeFrom(const SetGetAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetGetAllRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.SetGetAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetGetAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetGetAllResponse : public ::google::protobuf::Message {
 public:
  SetGetAllResponse();
  virtual ~SetGetAllResponse();

  SetGetAllResponse(const SetGetAllResponse& from);

  inline SetGetAllResponse& operator=(const SetGetAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetGetAllResponse& default_instance();

  void Swap(SetGetAllResponse* other);

  // implements Message ----------------------------------------------

  inline SetGetAllResponse* New() const { return New(NULL); }

  SetGetAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetGetAllResponse& from);
  void MergeFrom(const SetGetAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetGetAllResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // repeated .uranium.api.Value values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.SetGetAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetGetAllResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetRemoveRequest : public ::google::protobuf::Message {
 public:
  SetRemoveRequest();
  virtual ~SetRemoveRequest();

  SetRemoveRequest(const SetRemoveRequest& from);

  inline SetRemoveRequest& operator=(const SetRemoveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRemoveRequest& default_instance();

  void Swap(SetRemoveRequest* other);

  // implements Message ----------------------------------------------

  inline SetRemoveRequest* New() const { return New(NULL); }

  SetRemoveRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRemoveRequest& from);
  void MergeFrom(const SetRemoveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetRemoveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // repeated .uranium.api.Value values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::uranium::api::Value& values(int index) const;
  ::uranium::api::Value* mutable_values(int index);
  ::uranium::api::Value* add_values();
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
      mutable_values();
  const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
      values() const;

  // @@protoc_insertion_point(class_scope:uranium.api.SetRemoveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  ::google::protobuf::RepeatedPtrField< ::uranium::api::Value > values_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetRemoveRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetRemoveResponse : public ::google::protobuf::Message {
 public:
  SetRemoveResponse();
  virtual ~SetRemoveResponse();

  SetRemoveResponse(const SetRemoveResponse& from);

  inline SetRemoveResponse& operator=(const SetRemoveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRemoveResponse& default_instance();

  void Swap(SetRemoveResponse* other);

  // implements Message ----------------------------------------------

  inline SetRemoveResponse* New() const { return New(NULL); }

  SetRemoveResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRemoveResponse& from);
  void MergeFrom(const SetRemoveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetRemoveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetRemoveResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetRemoveResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetRemoveAllRequest : public ::google::protobuf::Message {
 public:
  SetRemoveAllRequest();
  virtual ~SetRemoveAllRequest();

  SetRemoveAllRequest(const SetRemoveAllRequest& from);

  inline SetRemoveAllRequest& operator=(const SetRemoveAllRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRemoveAllRequest& default_instance();

  void Swap(SetRemoveAllRequest* other);

  // implements Message ----------------------------------------------

  inline SetRemoveAllRequest* New() const { return New(NULL); }

  SetRemoveAllRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRemoveAllRequest& from);
  void MergeFrom(const SetRemoveAllRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetRemoveAllRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 1;
  const ::uranium::common::TableName& table_name() const;
  ::uranium::common::TableName* mutable_table_name();
  ::uranium::common::TableName* release_table_name();
  void set_allocated_table_name(::uranium::common::TableName* table_name);

  // optional .uranium.api.Key key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::uranium::api::Key& key() const;
  ::uranium::api::Key* mutable_key();
  ::uranium::api::Key* release_key();
  void set_allocated_key(::uranium::api::Key* key);

  // @@protoc_insertion_point(class_scope:uranium.api.SetRemoveAllRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::uranium::common::TableName* table_name_;
  ::uranium::api::Key* key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetRemoveAllRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetRemoveAllResponse : public ::google::protobuf::Message {
 public:
  SetRemoveAllResponse();
  virtual ~SetRemoveAllResponse();

  SetRemoveAllResponse(const SetRemoveAllResponse& from);

  inline SetRemoveAllResponse& operator=(const SetRemoveAllResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRemoveAllResponse& default_instance();

  void Swap(SetRemoveAllResponse* other);

  // implements Message ----------------------------------------------

  inline SetRemoveAllResponse* New() const { return New(NULL); }

  SetRemoveAllResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetRemoveAllResponse& from);
  void MergeFrom(const SetRemoveAllResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetRemoveAllResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .uranium.common.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::uranium::common::Status status() const;
  void set_status(::uranium::common::Status value);

  // @@protoc_insertion_point(class_scope:uranium.api.SetRemoveAllResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_uranium_2eproto();
  friend void protobuf_AssignDesc_uranium_2eproto();
  friend void protobuf_ShutdownFile_uranium_2eproto();

  void InitAsDefaultInstance();
  static SetRemoveAllResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Key

// optional bytes key = 1;
inline void Key::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Key::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.Key.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Key::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:uranium.api.Key.key)
}
inline void Key::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:uranium.api.Key.key)
}
inline void Key::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:uranium.api.Key.key)
}
inline ::std::string* Key::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:uranium.api.Key.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Key::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.Key.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Key::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:uranium.api.Key.key)
}

// -------------------------------------------------------------------

// Value

// optional bytes value = 1;
inline void Value::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Value::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.Value.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:uranium.api.Value.value)
}
inline void Value::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:uranium.api.Value.value)
}
inline void Value::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:uranium.api.Value.value)
}
inline ::std::string* Value::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:uranium.api.Value.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.Value.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:uranium.api.Value.value)
}

// -------------------------------------------------------------------

// KeyValue

// optional .uranium.api.Key key = 1;
inline bool KeyValue::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void KeyValue::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.KeyValue.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* KeyValue::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.KeyValue.key)
  return key_;
}
inline ::uranium::api::Key* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.KeyValue.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void KeyValue::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.KeyValue.key)
}

// optional .uranium.api.Value value = 2;
inline bool KeyValue::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void KeyValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& KeyValue::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.KeyValue.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* KeyValue::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.KeyValue.value)
  return value_;
}
inline ::uranium::api::Value* KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.KeyValue.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void KeyValue::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.KeyValue.value)
}

// -------------------------------------------------------------------

// Field

// optional bytes field = 1;
inline void Field::clear_field() {
  field_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Field::field() const {
  // @@protoc_insertion_point(field_get:uranium.api.Field.field)
  return field_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_field(const ::std::string& value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:uranium.api.Field.field)
}
inline void Field::set_field(const char* value) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:uranium.api.Field.field)
}
inline void Field::set_field(const void* value, size_t size) {
  
  field_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:uranium.api.Field.field)
}
inline ::std::string* Field::mutable_field() {
  
  // @@protoc_insertion_point(field_mutable:uranium.api.Field.field)
  return field_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_field() {
  // @@protoc_insertion_point(field_release:uranium.api.Field.field)
  
  return field_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_field(::std::string* field) {
  if (field != NULL) {
    
  } else {
    
  }
  field_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field);
  // @@protoc_insertion_point(field_set_allocated:uranium.api.Field.field)
}

// -------------------------------------------------------------------

// FieldValue

// optional .uranium.api.Field key = 1;
inline bool FieldValue::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void FieldValue::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Field& FieldValue::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.FieldValue.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Field* FieldValue::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Field;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.FieldValue.key)
  return key_;
}
inline ::uranium::api::Field* FieldValue::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.FieldValue.key)
  
  ::uranium::api::Field* temp = key_;
  key_ = NULL;
  return temp;
}
inline void FieldValue::set_allocated_key(::uranium::api::Field* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.FieldValue.key)
}

// optional .uranium.api.Value value = 2;
inline bool FieldValue::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void FieldValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& FieldValue::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.FieldValue.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* FieldValue::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.FieldValue.value)
  return value_;
}
inline ::uranium::api::Value* FieldValue::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.FieldValue.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void FieldValue::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.FieldValue.value)
}

// -------------------------------------------------------------------

// KVGetRequest

// optional .uranium.common.TableName table_name = 1;
inline bool KVGetRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void KVGetRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& KVGetRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVGetRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* KVGetRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.KVGetRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* KVGetRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.KVGetRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void KVGetRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.KVGetRequest.table_name)
}

// repeated .uranium.api.Key keys = 2;
inline int KVGetRequest::keys_size() const {
  return keys_.size();
}
inline void KVGetRequest::clear_keys() {
  keys_.Clear();
}
inline const ::uranium::api::Key& KVGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.KVGetRequest.keys)
  return keys_.Get(index);
}
inline ::uranium::api::Key* KVGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.KVGetRequest.keys)
  return keys_.Mutable(index);
}
inline ::uranium::api::Key* KVGetRequest::add_keys() {
  // @@protoc_insertion_point(field_add:uranium.api.KVGetRequest.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >*
KVGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.KVGetRequest.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >&
KVGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:uranium.api.KVGetRequest.keys)
  return keys_;
}

// -------------------------------------------------------------------

// KVGetResponse

// optional .uranium.common.Status status = 1;
inline void KVGetResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status KVGetResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVGetResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void KVGetResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.KVGetResponse.status)
}

// repeated .uranium.api.KeyValue kvs = 2;
inline int KVGetResponse::kvs_size() const {
  return kvs_.size();
}
inline void KVGetResponse::clear_kvs() {
  kvs_.Clear();
}
inline const ::uranium::api::KeyValue& KVGetResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.KVGetResponse.kvs)
  return kvs_.Get(index);
}
inline ::uranium::api::KeyValue* KVGetResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.KVGetResponse.kvs)
  return kvs_.Mutable(index);
}
inline ::uranium::api::KeyValue* KVGetResponse::add_kvs() {
  // @@protoc_insertion_point(field_add:uranium.api.KVGetResponse.kvs)
  return kvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >*
KVGetResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.KVGetResponse.kvs)
  return &kvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >&
KVGetResponse::kvs() const {
  // @@protoc_insertion_point(field_list:uranium.api.KVGetResponse.kvs)
  return kvs_;
}

// -------------------------------------------------------------------

// KVSetRequest

// optional .uranium.common.TableName table_name = 1;
inline bool KVSetRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void KVSetRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& KVSetRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVSetRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* KVSetRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.KVSetRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* KVSetRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.KVSetRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void KVSetRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.KVSetRequest.table_name)
}

// repeated .uranium.api.KeyValue kvs = 2;
inline int KVSetRequest::kvs_size() const {
  return kvs_.size();
}
inline void KVSetRequest::clear_kvs() {
  kvs_.Clear();
}
inline const ::uranium::api::KeyValue& KVSetRequest::kvs(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.KVSetRequest.kvs)
  return kvs_.Get(index);
}
inline ::uranium::api::KeyValue* KVSetRequest::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.KVSetRequest.kvs)
  return kvs_.Mutable(index);
}
inline ::uranium::api::KeyValue* KVSetRequest::add_kvs() {
  // @@protoc_insertion_point(field_add:uranium.api.KVSetRequest.kvs)
  return kvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >*
KVSetRequest::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.KVSetRequest.kvs)
  return &kvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::KeyValue >&
KVSetRequest::kvs() const {
  // @@protoc_insertion_point(field_list:uranium.api.KVSetRequest.kvs)
  return kvs_;
}

// -------------------------------------------------------------------

// KVSetResponse

// optional .uranium.common.Status status = 1;
inline void KVSetResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status KVSetResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVSetResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void KVSetResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.KVSetResponse.status)
}

// -------------------------------------------------------------------

// KVRemoveRequest

// optional .uranium.common.TableName table_name = 1;
inline bool KVRemoveRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void KVRemoveRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& KVRemoveRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVRemoveRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* KVRemoveRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.KVRemoveRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* KVRemoveRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.KVRemoveRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void KVRemoveRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.KVRemoveRequest.table_name)
}

// repeated .uranium.api.Key keys = 2;
inline int KVRemoveRequest::keys_size() const {
  return keys_.size();
}
inline void KVRemoveRequest::clear_keys() {
  keys_.Clear();
}
inline const ::uranium::api::Key& KVRemoveRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.KVRemoveRequest.keys)
  return keys_.Get(index);
}
inline ::uranium::api::Key* KVRemoveRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.KVRemoveRequest.keys)
  return keys_.Mutable(index);
}
inline ::uranium::api::Key* KVRemoveRequest::add_keys() {
  // @@protoc_insertion_point(field_add:uranium.api.KVRemoveRequest.keys)
  return keys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >*
KVRemoveRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.KVRemoveRequest.keys)
  return &keys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Key >&
KVRemoveRequest::keys() const {
  // @@protoc_insertion_point(field_list:uranium.api.KVRemoveRequest.keys)
  return keys_;
}

// -------------------------------------------------------------------

// KVRemoveResponse

// optional .uranium.common.Status status = 1;
inline void KVRemoveResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status KVRemoveResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.KVRemoveResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void KVRemoveResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.KVRemoveResponse.status)
}

// -------------------------------------------------------------------

// ListLPushRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListLPushRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListLPushRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListLPushRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListLPushRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListLPushRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPushRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListLPushRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPushRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListLPushRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListLPushRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListLPushRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListLPushRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListLPushRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPushRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListLPushRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPushRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int ListLPushRequest::values_size() const {
  return values_.size();
}
inline void ListLPushRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& ListLPushRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* ListLPushRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* ListLPushRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.ListLPushRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
ListLPushRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.ListLPushRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
ListLPushRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.ListLPushRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// ListLPushResponse

// optional .uranium.common.Status status = 1;
inline void ListLPushResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListLPushResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListLPushResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListLPushResponse.status)
}

// -------------------------------------------------------------------

// ListLPopRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListLPopRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListLPopRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListLPopRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPopRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListLPopRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPopRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListLPopRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPopRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListLPopRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPopRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListLPopRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListLPopRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListLPopRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPopRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListLPopRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPopRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListLPopRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPopRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListLPopRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPopRequest.key)
}

// -------------------------------------------------------------------

// ListLPopResponse

// optional .uranium.common.Status status = 1;
inline void ListLPopResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListLPopResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPopResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListLPopResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListLPopResponse.status)
}

// optional .uranium.api.Value value = 2;
inline bool ListLPopResponse::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ListLPopResponse::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& ListLPopResponse::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPopResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* ListLPopResponse::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPopResponse.value)
  return value_;
}
inline ::uranium::api::Value* ListLPopResponse::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPopResponse.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ListLPopResponse::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPopResponse.value)
}

// -------------------------------------------------------------------

// ListRPushRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListRPushRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListRPushRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListRPushRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListRPushRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListRPushRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPushRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListRPushRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPushRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListRPushRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListRPushRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListRPushRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListRPushRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListRPushRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPushRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListRPushRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPushRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int ListRPushRequest::values_size() const {
  return values_.size();
}
inline void ListRPushRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& ListRPushRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* ListRPushRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* ListRPushRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.ListRPushRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
ListRPushRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.ListRPushRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
ListRPushRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.ListRPushRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// ListRPushResponse

// optional .uranium.common.Status status = 1;
inline void ListRPushResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListRPushResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListRPushResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRPushResponse.status)
}

// -------------------------------------------------------------------

// ListRPopRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListRPopRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListRPopRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListRPopRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPopRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListRPopRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPopRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListRPopRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPopRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListRPopRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPopRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListRPopRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListRPopRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListRPopRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPopRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListRPopRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPopRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListRPopRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPopRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListRPopRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPopRequest.key)
}

// -------------------------------------------------------------------

// ListRPopResponse

// optional .uranium.common.Status status = 1;
inline void ListRPopResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListRPopResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPopResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListRPopResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRPopResponse.status)
}

// optional .uranium.api.Value value = 2;
inline bool ListRPopResponse::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ListRPopResponse::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& ListRPopResponse::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPopResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* ListRPopResponse::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPopResponse.value)
  return value_;
}
inline ::uranium::api::Value* ListRPopResponse::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPopResponse.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ListRPopResponse::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPopResponse.value)
}

// -------------------------------------------------------------------

// ListLPushXRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListLPushXRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListLPushXRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListLPushXRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushXRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListLPushXRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushXRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListLPushXRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPushXRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListLPushXRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPushXRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListLPushXRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListLPushXRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListLPushXRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushXRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListLPushXRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushXRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListLPushXRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLPushXRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListLPushXRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLPushXRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int ListLPushXRequest::values_size() const {
  return values_.size();
}
inline void ListLPushXRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& ListLPushXRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushXRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* ListLPushXRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLPushXRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* ListLPushXRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.ListLPushXRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
ListLPushXRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.ListLPushXRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
ListLPushXRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.ListLPushXRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// ListLPushXResponse

// optional .uranium.common.Status status = 1;
inline void ListLPushXResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListLPushXResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLPushXResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListLPushXResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListLPushXResponse.status)
}

// -------------------------------------------------------------------

// ListRPushXRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListRPushXRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListRPushXRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListRPushXRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushXRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListRPushXRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushXRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListRPushXRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPushXRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListRPushXRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPushXRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListRPushXRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListRPushXRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListRPushXRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushXRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListRPushXRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushXRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListRPushXRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRPushXRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListRPushXRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRPushXRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int ListRPushXRequest::values_size() const {
  return values_.size();
}
inline void ListRPushXRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& ListRPushXRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushXRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* ListRPushXRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRPushXRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* ListRPushXRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.ListRPushXRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
ListRPushXRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.ListRPushXRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
ListRPushXRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.ListRPushXRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// ListRPushXResponse

// optional .uranium.common.Status status = 1;
inline void ListRPushXResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListRPushXResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRPushXResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListRPushXResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRPushXResponse.status)
}

// -------------------------------------------------------------------

// ListIndexRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListIndexRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListIndexRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListIndexRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListIndexRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListIndexRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListIndexRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListIndexRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListIndexRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListIndexRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListIndexRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListIndexRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListIndexRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListIndexRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListIndexRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListIndexRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListIndexRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListIndexRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListIndexRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListIndexRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListIndexRequest.key)
}

// optional int64 index = 3;
inline void ListIndexRequest::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ListIndexRequest::index() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListIndexRequest.index)
  return index_;
}
inline void ListIndexRequest::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListIndexRequest.index)
}

// -------------------------------------------------------------------

// ListIndexResponse

// optional .uranium.common.Status status = 1;
inline void ListIndexResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListIndexResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListIndexResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListIndexResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListIndexResponse.status)
}

// optional .uranium.api.Value value = 2;
inline bool ListIndexResponse::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ListIndexResponse::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& ListIndexResponse::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListIndexResponse.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* ListIndexResponse::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListIndexResponse.value)
  return value_;
}
inline ::uranium::api::Value* ListIndexResponse::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.ListIndexResponse.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ListIndexResponse::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListIndexResponse.value)
}

// -------------------------------------------------------------------

// ListSetRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListSetRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListSetRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListSetRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListSetRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListSetRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListSetRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListSetRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListSetRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListSetRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListSetRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListSetRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListSetRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListSetRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListSetRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListSetRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListSetRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListSetRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListSetRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListSetRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListSetRequest.key)
}

// optional int64 index = 3;
inline void ListSetRequest::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ListSetRequest::index() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListSetRequest.index)
  return index_;
}
inline void ListSetRequest::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListSetRequest.index)
}

// optional .uranium.api.Value value = 4;
inline bool ListSetRequest::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void ListSetRequest::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& ListSetRequest::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListSetRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* ListSetRequest::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListSetRequest.value)
  return value_;
}
inline ::uranium::api::Value* ListSetRequest::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.ListSetRequest.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void ListSetRequest::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListSetRequest.value)
}

// -------------------------------------------------------------------

// ListSetResponse

// optional .uranium.common.Status status = 1;
inline void ListSetResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListSetResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListSetResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListSetResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListSetResponse.status)
}

// -------------------------------------------------------------------

// ListRangeRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListRangeRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListRangeRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListRangeRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListRangeRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRangeRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListRangeRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRangeRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListRangeRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRangeRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListRangeRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListRangeRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListRangeRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListRangeRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRangeRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListRangeRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRangeRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListRangeRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRangeRequest.key)
}

// optional int64 start = 3;
inline void ListRangeRequest::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ListRangeRequest::start() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeRequest.start)
  return start_;
}
inline void ListRangeRequest::set_start(::google::protobuf::int64 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRangeRequest.start)
}

// optional int64 end = 4;
inline void ListRangeRequest::clear_end() {
  end_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ListRangeRequest::end() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeRequest.end)
  return end_;
}
inline void ListRangeRequest::set_end(::google::protobuf::int64 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRangeRequest.end)
}

// -------------------------------------------------------------------

// ListRangeResponse

// optional .uranium.common.Status status = 1;
inline void ListRangeResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListRangeResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListRangeResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRangeResponse.status)
}

// repeated .uranium.api.Value values = 2;
inline int ListRangeResponse::values_size() const {
  return values_.size();
}
inline void ListRangeResponse::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& ListRangeResponse::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRangeResponse.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* ListRangeResponse::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRangeResponse.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* ListRangeResponse::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.ListRangeResponse.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
ListRangeResponse::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.ListRangeResponse.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
ListRangeResponse::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.ListRangeResponse.values)
  return values_;
}

// -------------------------------------------------------------------

// ListLengthRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListLengthRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListLengthRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListLengthRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLengthRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListLengthRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLengthRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListLengthRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLengthRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListLengthRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLengthRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListLengthRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListLengthRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListLengthRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLengthRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListLengthRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListLengthRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListLengthRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListLengthRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListLengthRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListLengthRequest.key)
}

// -------------------------------------------------------------------

// ListLengthResponse

// optional .uranium.common.Status status = 1;
inline void ListLengthResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListLengthResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLengthResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListLengthResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListLengthResponse.status)
}

// optional int64 length = 2;
inline void ListLengthResponse::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ListLengthResponse::length() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListLengthResponse.length)
  return length_;
}
inline void ListLengthResponse::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListLengthResponse.length)
}

// -------------------------------------------------------------------

// ListRemoveAllRequest

// optional .uranium.common.TableName table_name = 1;
inline bool ListRemoveAllRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void ListRemoveAllRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& ListRemoveAllRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRemoveAllRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* ListRemoveAllRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRemoveAllRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* ListRemoveAllRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRemoveAllRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void ListRemoveAllRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRemoveAllRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool ListRemoveAllRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void ListRemoveAllRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& ListRemoveAllRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRemoveAllRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* ListRemoveAllRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.ListRemoveAllRequest.key)
  return key_;
}
inline ::uranium::api::Key* ListRemoveAllRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.ListRemoveAllRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ListRemoveAllRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.ListRemoveAllRequest.key)
}

// -------------------------------------------------------------------

// ListRemoveAllResponse

// optional .uranium.common.Status status = 1;
inline void ListRemoveAllResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status ListRemoveAllResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.ListRemoveAllResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void ListRemoveAllResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.ListRemoveAllResponse.status)
}

// -------------------------------------------------------------------

// HashGetRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashGetRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashGetRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashGetRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashGetRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashGetRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashGetRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashGetRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashGetRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashGetRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashGetRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashGetRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetRequest.key)
}

// repeated .uranium.api.Field fields = 3;
inline int HashGetRequest::fields_size() const {
  return fields_.size();
}
inline void HashGetRequest::clear_fields() {
  fields_.Clear();
}
inline const ::uranium::api::Field& HashGetRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetRequest.fields)
  return fields_.Get(index);
}
inline ::uranium::api::Field* HashGetRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetRequest.fields)
  return fields_.Mutable(index);
}
inline ::uranium::api::Field* HashGetRequest::add_fields() {
  // @@protoc_insertion_point(field_add:uranium.api.HashGetRequest.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
HashGetRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashGetRequest.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
HashGetRequest::fields() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashGetRequest.fields)
  return fields_;
}

// -------------------------------------------------------------------

// HashGetResponse

// optional .uranium.common.Status status = 1;
inline void HashGetResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashGetResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashGetResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashGetResponse.status)
}

// repeated .uranium.api.FieldValue fvs = 2;
inline int HashGetResponse::fvs_size() const {
  return fvs_.size();
}
inline void HashGetResponse::clear_fvs() {
  fvs_.Clear();
}
inline const ::uranium::api::FieldValue& HashGetResponse::fvs(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetResponse.fvs)
  return fvs_.Get(index);
}
inline ::uranium::api::FieldValue* HashGetResponse::mutable_fvs(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetResponse.fvs)
  return fvs_.Mutable(index);
}
inline ::uranium::api::FieldValue* HashGetResponse::add_fvs() {
  // @@protoc_insertion_point(field_add:uranium.api.HashGetResponse.fvs)
  return fvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
HashGetResponse::mutable_fvs() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashGetResponse.fvs)
  return &fvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
HashGetResponse::fvs() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashGetResponse.fvs)
  return fvs_;
}

// -------------------------------------------------------------------

// HashGetAllRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashGetAllRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashGetAllRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashGetAllRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashGetAllRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashGetAllRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashGetAllRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashGetAllRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashGetAllRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashGetAllRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashGetAllRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashGetAllRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashGetAllRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllRequest.key)
}

// -------------------------------------------------------------------

// HashGetAllResponse

// optional .uranium.common.Status status = 1;
inline void HashGetAllResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashGetAllResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashGetAllResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashGetAllResponse.status)
}

// repeated .uranium.api.FieldValue fvs = 2;
inline int HashGetAllResponse::fvs_size() const {
  return fvs_.size();
}
inline void HashGetAllResponse::clear_fvs() {
  fvs_.Clear();
}
inline const ::uranium::api::FieldValue& HashGetAllResponse::fvs(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllResponse.fvs)
  return fvs_.Get(index);
}
inline ::uranium::api::FieldValue* HashGetAllResponse::mutable_fvs(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllResponse.fvs)
  return fvs_.Mutable(index);
}
inline ::uranium::api::FieldValue* HashGetAllResponse::add_fvs() {
  // @@protoc_insertion_point(field_add:uranium.api.HashGetAllResponse.fvs)
  return fvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
HashGetAllResponse::mutable_fvs() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashGetAllResponse.fvs)
  return &fvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
HashGetAllResponse::fvs() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashGetAllResponse.fvs)
  return fvs_;
}

// -------------------------------------------------------------------

// HashGetAllFieldsRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashGetAllFieldsRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashGetAllFieldsRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashGetAllFieldsRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllFieldsRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashGetAllFieldsRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllFieldsRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashGetAllFieldsRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllFieldsRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashGetAllFieldsRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllFieldsRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashGetAllFieldsRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashGetAllFieldsRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashGetAllFieldsRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllFieldsRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashGetAllFieldsRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllFieldsRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashGetAllFieldsRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllFieldsRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashGetAllFieldsRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllFieldsRequest.key)
}

// -------------------------------------------------------------------

// HashGetAllFieldsResponse

// optional .uranium.common.Status status = 1;
inline void HashGetAllFieldsResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashGetAllFieldsResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllFieldsResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashGetAllFieldsResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashGetAllFieldsResponse.status)
}

// repeated .uranium.api.Field fields = 2;
inline int HashGetAllFieldsResponse::fields_size() const {
  return fields_.size();
}
inline void HashGetAllFieldsResponse::clear_fields() {
  fields_.Clear();
}
inline const ::uranium::api::Field& HashGetAllFieldsResponse::fields(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllFieldsResponse.fields)
  return fields_.Get(index);
}
inline ::uranium::api::Field* HashGetAllFieldsResponse::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllFieldsResponse.fields)
  return fields_.Mutable(index);
}
inline ::uranium::api::Field* HashGetAllFieldsResponse::add_fields() {
  // @@protoc_insertion_point(field_add:uranium.api.HashGetAllFieldsResponse.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
HashGetAllFieldsResponse::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashGetAllFieldsResponse.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
HashGetAllFieldsResponse::fields() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashGetAllFieldsResponse.fields)
  return fields_;
}

// -------------------------------------------------------------------

// HashGetAllValuesRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashGetAllValuesRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashGetAllValuesRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashGetAllValuesRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllValuesRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashGetAllValuesRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllValuesRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashGetAllValuesRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllValuesRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashGetAllValuesRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllValuesRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashGetAllValuesRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashGetAllValuesRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashGetAllValuesRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllValuesRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashGetAllValuesRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllValuesRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashGetAllValuesRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashGetAllValuesRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashGetAllValuesRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashGetAllValuesRequest.key)
}

// -------------------------------------------------------------------

// HashGetAllValuesResponse

// optional .uranium.common.Status status = 1;
inline void HashGetAllValuesResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashGetAllValuesResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllValuesResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashGetAllValuesResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashGetAllValuesResponse.status)
}

// repeated .uranium.api.Value values = 2;
inline int HashGetAllValuesResponse::values_size() const {
  return values_.size();
}
inline void HashGetAllValuesResponse::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& HashGetAllValuesResponse::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashGetAllValuesResponse.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* HashGetAllValuesResponse::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashGetAllValuesResponse.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* HashGetAllValuesResponse::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.HashGetAllValuesResponse.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
HashGetAllValuesResponse::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashGetAllValuesResponse.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
HashGetAllValuesResponse::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashGetAllValuesResponse.values)
  return values_;
}

// -------------------------------------------------------------------

// HashLengthRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashLengthRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashLengthRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashLengthRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashLengthRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashLengthRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashLengthRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashLengthRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashLengthRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashLengthRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashLengthRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashLengthRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashLengthRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashLengthRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashLengthRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashLengthRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashLengthRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashLengthRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashLengthRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashLengthRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashLengthRequest.key)
}

// -------------------------------------------------------------------

// HashLengthResponse

// optional .uranium.common.Status status = 1;
inline void HashLengthResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashLengthResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashLengthResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashLengthResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashLengthResponse.status)
}

// optional int64 length = 2;
inline void HashLengthResponse::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HashLengthResponse::length() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashLengthResponse.length)
  return length_;
}
inline void HashLengthResponse::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashLengthResponse.length)
}

// -------------------------------------------------------------------

// HashSetRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashSetRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashSetRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashSetRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashSetRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashSetRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashSetRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashSetRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashSetRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashSetRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashSetRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashSetRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashSetRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashSetRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashSetRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashSetRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashSetRequest.key)
}

// repeated .uranium.api.FieldValue fvs = 3;
inline int HashSetRequest::fvs_size() const {
  return fvs_.size();
}
inline void HashSetRequest::clear_fvs() {
  fvs_.Clear();
}
inline const ::uranium::api::FieldValue& HashSetRequest::fvs(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetRequest.fvs)
  return fvs_.Get(index);
}
inline ::uranium::api::FieldValue* HashSetRequest::mutable_fvs(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetRequest.fvs)
  return fvs_.Mutable(index);
}
inline ::uranium::api::FieldValue* HashSetRequest::add_fvs() {
  // @@protoc_insertion_point(field_add:uranium.api.HashSetRequest.fvs)
  return fvs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >*
HashSetRequest::mutable_fvs() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashSetRequest.fvs)
  return &fvs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::FieldValue >&
HashSetRequest::fvs() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashSetRequest.fvs)
  return fvs_;
}

// -------------------------------------------------------------------

// HashSetResponse

// optional .uranium.common.Status status = 1;
inline void HashSetResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashSetResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashSetResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashSetResponse.status)
}

// -------------------------------------------------------------------

// HashSetXRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashSetXRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashSetXRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashSetXRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetXRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashSetXRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetXRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashSetXRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashSetXRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashSetXRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashSetXRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashSetXRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashSetXRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashSetXRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetXRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashSetXRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetXRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashSetXRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashSetXRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashSetXRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashSetXRequest.key)
}

// optional .uranium.api.FieldValue fv = 3;
inline bool HashSetXRequest::has_fv() const {
  return !_is_default_instance_ && fv_ != NULL;
}
inline void HashSetXRequest::clear_fv() {
  if (GetArenaNoVirtual() == NULL && fv_ != NULL) delete fv_;
  fv_ = NULL;
}
inline const ::uranium::api::FieldValue& HashSetXRequest::fv() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetXRequest.fv)
  return fv_ != NULL ? *fv_ : *default_instance_->fv_;
}
inline ::uranium::api::FieldValue* HashSetXRequest::mutable_fv() {
  
  if (fv_ == NULL) {
    fv_ = new ::uranium::api::FieldValue;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashSetXRequest.fv)
  return fv_;
}
inline ::uranium::api::FieldValue* HashSetXRequest::release_fv() {
  // @@protoc_insertion_point(field_release:uranium.api.HashSetXRequest.fv)
  
  ::uranium::api::FieldValue* temp = fv_;
  fv_ = NULL;
  return temp;
}
inline void HashSetXRequest::set_allocated_fv(::uranium::api::FieldValue* fv) {
  delete fv_;
  fv_ = fv;
  if (fv) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashSetXRequest.fv)
}

// -------------------------------------------------------------------

// HashSetXResponse

// optional .uranium.common.Status status = 1;
inline void HashSetXResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashSetXResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashSetXResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashSetXResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashSetXResponse.status)
}

// -------------------------------------------------------------------

// HashRemoveRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashRemoveRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashRemoveRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashRemoveRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashRemoveRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashRemoveRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashRemoveRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashRemoveRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashRemoveRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashRemoveRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashRemoveRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashRemoveRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashRemoveRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashRemoveRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashRemoveRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashRemoveRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashRemoveRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashRemoveRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashRemoveRequest.key)
}

// repeated .uranium.api.Field fields = 3;
inline int HashRemoveRequest::fields_size() const {
  return fields_.size();
}
inline void HashRemoveRequest::clear_fields() {
  fields_.Clear();
}
inline const ::uranium::api::Field& HashRemoveRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveRequest.fields)
  return fields_.Get(index);
}
inline ::uranium::api::Field* HashRemoveRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.HashRemoveRequest.fields)
  return fields_.Mutable(index);
}
inline ::uranium::api::Field* HashRemoveRequest::add_fields() {
  // @@protoc_insertion_point(field_add:uranium.api.HashRemoveRequest.fields)
  return fields_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >*
HashRemoveRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.HashRemoveRequest.fields)
  return &fields_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Field >&
HashRemoveRequest::fields() const {
  // @@protoc_insertion_point(field_list:uranium.api.HashRemoveRequest.fields)
  return fields_;
}

// -------------------------------------------------------------------

// HashRemoveResponse

// optional .uranium.common.Status status = 1;
inline void HashRemoveResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashRemoveResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashRemoveResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashRemoveResponse.status)
}

// -------------------------------------------------------------------

// HashExistsRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashExistsRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashExistsRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashExistsRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashExistsRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashExistsRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashExistsRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashExistsRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashExistsRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashExistsRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashExistsRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashExistsRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashExistsRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashExistsRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashExistsRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashExistsRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashExistsRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashExistsRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashExistsRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashExistsRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashExistsRequest.key)
}

// optional .uranium.api.Field field = 3;
inline bool HashExistsRequest::has_field() const {
  return !_is_default_instance_ && field_ != NULL;
}
inline void HashExistsRequest::clear_field() {
  if (GetArenaNoVirtual() == NULL && field_ != NULL) delete field_;
  field_ = NULL;
}
inline const ::uranium::api::Field& HashExistsRequest::field() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashExistsRequest.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::uranium::api::Field* HashExistsRequest::mutable_field() {
  
  if (field_ == NULL) {
    field_ = new ::uranium::api::Field;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashExistsRequest.field)
  return field_;
}
inline ::uranium::api::Field* HashExistsRequest::release_field() {
  // @@protoc_insertion_point(field_release:uranium.api.HashExistsRequest.field)
  
  ::uranium::api::Field* temp = field_;
  field_ = NULL;
  return temp;
}
inline void HashExistsRequest::set_allocated_field(::uranium::api::Field* field) {
  delete field_;
  field_ = field;
  if (field) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashExistsRequest.field)
}

// -------------------------------------------------------------------

// HashExistsResponse

// optional .uranium.common.Status status = 1;
inline void HashExistsResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashExistsResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashExistsResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashExistsResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashExistsResponse.status)
}

// optional bool exists = 2;
inline void HashExistsResponse::clear_exists() {
  exists_ = false;
}
inline bool HashExistsResponse::exists() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashExistsResponse.exists)
  return exists_;
}
inline void HashExistsResponse::set_exists(bool value) {
  
  exists_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashExistsResponse.exists)
}

// -------------------------------------------------------------------

// HashRemoveAllRequest

// optional .uranium.common.TableName table_name = 1;
inline bool HashRemoveAllRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void HashRemoveAllRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& HashRemoveAllRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveAllRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* HashRemoveAllRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashRemoveAllRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* HashRemoveAllRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.HashRemoveAllRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void HashRemoveAllRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashRemoveAllRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool HashRemoveAllRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void HashRemoveAllRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& HashRemoveAllRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveAllRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* HashRemoveAllRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.HashRemoveAllRequest.key)
  return key_;
}
inline ::uranium::api::Key* HashRemoveAllRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.HashRemoveAllRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void HashRemoveAllRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.HashRemoveAllRequest.key)
}

// -------------------------------------------------------------------

// HashRemoveAllResponse

// optional .uranium.common.Status status = 1;
inline void HashRemoveAllResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status HashRemoveAllResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.HashRemoveAllResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void HashRemoveAllResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.HashRemoveAllResponse.status)
}

// -------------------------------------------------------------------

// SetAddRequest

// optional .uranium.common.TableName table_name = 1;
inline bool SetAddRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void SetAddRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& SetAddRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetAddRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* SetAddRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetAddRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* SetAddRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.SetAddRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void SetAddRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetAddRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool SetAddRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetAddRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetAddRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetAddRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetAddRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetAddRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetAddRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetAddRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetAddRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetAddRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int SetAddRequest::values_size() const {
  return values_.size();
}
inline void SetAddRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& SetAddRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.SetAddRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* SetAddRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.SetAddRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* SetAddRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.SetAddRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
SetAddRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.SetAddRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
SetAddRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.SetAddRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// SetAddResponse

// optional .uranium.common.Status status = 1;
inline void SetAddResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetAddResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetAddResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetAddResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetAddResponse.status)
}

// -------------------------------------------------------------------

// SetLengthRequest

// optional .uranium.common.TableName table_name = 1;
inline bool SetLengthRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void SetLengthRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& SetLengthRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetLengthRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* SetLengthRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetLengthRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* SetLengthRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.SetLengthRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void SetLengthRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetLengthRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool SetLengthRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetLengthRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetLengthRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetLengthRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetLengthRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetLengthRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetLengthRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetLengthRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetLengthRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetLengthRequest.key)
}

// -------------------------------------------------------------------

// SetLengthResponse

// optional .uranium.common.Status status = 1;
inline void SetLengthResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetLengthResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetLengthResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetLengthResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetLengthResponse.status)
}

// optional int64 length = 2;
inline void SetLengthResponse::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SetLengthResponse::length() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetLengthResponse.length)
  return length_;
}
inline void SetLengthResponse::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetLengthResponse.length)
}

// -------------------------------------------------------------------

// SetIsMemberRequest

// optional .uranium.common.Status status = 1;
inline void SetIsMemberRequest::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetIsMemberRequest::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetIsMemberRequest.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetIsMemberRequest::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetIsMemberRequest.status)
}

// optional .uranium.api.Key key = 2;
inline bool SetIsMemberRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetIsMemberRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetIsMemberRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetIsMemberRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetIsMemberRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetIsMemberRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetIsMemberRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetIsMemberRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetIsMemberRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetIsMemberRequest.key)
}

// optional .uranium.api.Value value = 3;
inline bool SetIsMemberRequest::has_value() const {
  return !_is_default_instance_ && value_ != NULL;
}
inline void SetIsMemberRequest::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) delete value_;
  value_ = NULL;
}
inline const ::uranium::api::Value& SetIsMemberRequest::value() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetIsMemberRequest.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::uranium::api::Value* SetIsMemberRequest::mutable_value() {
  
  if (value_ == NULL) {
    value_ = new ::uranium::api::Value;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetIsMemberRequest.value)
  return value_;
}
inline ::uranium::api::Value* SetIsMemberRequest::release_value() {
  // @@protoc_insertion_point(field_release:uranium.api.SetIsMemberRequest.value)
  
  ::uranium::api::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void SetIsMemberRequest::set_allocated_value(::uranium::api::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetIsMemberRequest.value)
}

// -------------------------------------------------------------------

// SetIsMemberResponse

// optional .uranium.common.Status status = 1;
inline void SetIsMemberResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetIsMemberResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetIsMemberResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetIsMemberResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetIsMemberResponse.status)
}

// optional bool yes = 2;
inline void SetIsMemberResponse::clear_yes() {
  yes_ = false;
}
inline bool SetIsMemberResponse::yes() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetIsMemberResponse.yes)
  return yes_;
}
inline void SetIsMemberResponse::set_yes(bool value) {
  
  yes_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetIsMemberResponse.yes)
}

// -------------------------------------------------------------------

// SetGetAllRequest

// optional .uranium.common.TableName table_name = 1;
inline bool SetGetAllRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void SetGetAllRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& SetGetAllRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetGetAllRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* SetGetAllRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetGetAllRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* SetGetAllRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.SetGetAllRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void SetGetAllRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetGetAllRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool SetGetAllRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetGetAllRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetGetAllRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetGetAllRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetGetAllRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetGetAllRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetGetAllRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetGetAllRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetGetAllRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetGetAllRequest.key)
}

// -------------------------------------------------------------------

// SetGetAllResponse

// optional .uranium.common.Status status = 1;
inline void SetGetAllResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetGetAllResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetGetAllResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetGetAllResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetGetAllResponse.status)
}

// repeated .uranium.api.Value values = 2;
inline int SetGetAllResponse::values_size() const {
  return values_.size();
}
inline void SetGetAllResponse::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& SetGetAllResponse::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.SetGetAllResponse.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* SetGetAllResponse::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.SetGetAllResponse.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* SetGetAllResponse::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.SetGetAllResponse.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
SetGetAllResponse::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.SetGetAllResponse.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
SetGetAllResponse::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.SetGetAllResponse.values)
  return values_;
}

// -------------------------------------------------------------------

// SetRemoveRequest

// optional .uranium.common.TableName table_name = 1;
inline bool SetRemoveRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void SetRemoveRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& SetRemoveRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* SetRemoveRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetRemoveRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* SetRemoveRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.SetRemoveRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void SetRemoveRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetRemoveRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool SetRemoveRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetRemoveRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetRemoveRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetRemoveRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetRemoveRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetRemoveRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetRemoveRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetRemoveRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetRemoveRequest.key)
}

// repeated .uranium.api.Value values = 3;
inline int SetRemoveRequest::values_size() const {
  return values_.size();
}
inline void SetRemoveRequest::clear_values() {
  values_.Clear();
}
inline const ::uranium::api::Value& SetRemoveRequest::values(int index) const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveRequest.values)
  return values_.Get(index);
}
inline ::uranium::api::Value* SetRemoveRequest::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:uranium.api.SetRemoveRequest.values)
  return values_.Mutable(index);
}
inline ::uranium::api::Value* SetRemoveRequest::add_values() {
  // @@protoc_insertion_point(field_add:uranium.api.SetRemoveRequest.values)
  return values_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >*
SetRemoveRequest::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:uranium.api.SetRemoveRequest.values)
  return &values_;
}
inline const ::google::protobuf::RepeatedPtrField< ::uranium::api::Value >&
SetRemoveRequest::values() const {
  // @@protoc_insertion_point(field_list:uranium.api.SetRemoveRequest.values)
  return values_;
}

// -------------------------------------------------------------------

// SetRemoveResponse

// optional .uranium.common.Status status = 1;
inline void SetRemoveResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetRemoveResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetRemoveResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetRemoveResponse.status)
}

// -------------------------------------------------------------------

// SetRemoveAllRequest

// optional .uranium.common.TableName table_name = 1;
inline bool SetRemoveAllRequest::has_table_name() const {
  return !_is_default_instance_ && table_name_ != NULL;
}
inline void SetRemoveAllRequest::clear_table_name() {
  if (GetArenaNoVirtual() == NULL && table_name_ != NULL) delete table_name_;
  table_name_ = NULL;
}
inline const ::uranium::common::TableName& SetRemoveAllRequest::table_name() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveAllRequest.table_name)
  return table_name_ != NULL ? *table_name_ : *default_instance_->table_name_;
}
inline ::uranium::common::TableName* SetRemoveAllRequest::mutable_table_name() {
  
  if (table_name_ == NULL) {
    table_name_ = new ::uranium::common::TableName;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetRemoveAllRequest.table_name)
  return table_name_;
}
inline ::uranium::common::TableName* SetRemoveAllRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:uranium.api.SetRemoveAllRequest.table_name)
  
  ::uranium::common::TableName* temp = table_name_;
  table_name_ = NULL;
  return temp;
}
inline void SetRemoveAllRequest::set_allocated_table_name(::uranium::common::TableName* table_name) {
  delete table_name_;
  table_name_ = table_name;
  if (table_name) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetRemoveAllRequest.table_name)
}

// optional .uranium.api.Key key = 2;
inline bool SetRemoveAllRequest::has_key() const {
  return !_is_default_instance_ && key_ != NULL;
}
inline void SetRemoveAllRequest::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::uranium::api::Key& SetRemoveAllRequest::key() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveAllRequest.key)
  return key_ != NULL ? *key_ : *default_instance_->key_;
}
inline ::uranium::api::Key* SetRemoveAllRequest::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::uranium::api::Key;
  }
  // @@protoc_insertion_point(field_mutable:uranium.api.SetRemoveAllRequest.key)
  return key_;
}
inline ::uranium::api::Key* SetRemoveAllRequest::release_key() {
  // @@protoc_insertion_point(field_release:uranium.api.SetRemoveAllRequest.key)
  
  ::uranium::api::Key* temp = key_;
  key_ = NULL;
  return temp;
}
inline void SetRemoveAllRequest::set_allocated_key(::uranium::api::Key* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:uranium.api.SetRemoveAllRequest.key)
}

// -------------------------------------------------------------------

// SetRemoveAllResponse

// optional .uranium.common.Status status = 1;
inline void SetRemoveAllResponse::clear_status() {
  status_ = 0;
}
inline ::uranium::common::Status SetRemoveAllResponse::status() const {
  // @@protoc_insertion_point(field_get:uranium.api.SetRemoveAllResponse.status)
  return static_cast< ::uranium::common::Status >(status_);
}
inline void SetRemoveAllResponse::set_status(::uranium::common::Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:uranium.api.SetRemoveAllResponse.status)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace uranium

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_uranium_2eproto__INCLUDED

// Generated by the gRPC protobuf plugin.
// If you make any local change, they will be lost.
// source: uranium.proto
#ifndef GRPC_uranium_2eproto__INCLUDED
#define GRPC_uranium_2eproto__INCLUDED

#include "uranium.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class RpcService;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace uranium {
namespace api {

// //// interfaces for k-v pair data structure
class UraniumKVService GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // get the value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not yet exist.
    virtual ::grpc::Status KVGet(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::uranium::api::KVGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVGetResponse>> AsyncKVGet(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVGetResponse>>(AsyncKVGetRaw(context, request, cq));
    }
    // set the value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status KVSet(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::uranium::api::KVSetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVSetResponse>> AsyncKVSet(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVSetResponse>>(AsyncKVSetRaw(context, request, cq));
    }
    // remove the value of a key, equal to set empty value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status KVRemove(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::uranium::api::KVRemoveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVRemoveResponse>> AsyncKVRemove(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVRemoveResponse>>(AsyncKVRemoveRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVGetResponse>* AsyncKVGetRaw(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVSetResponse>* AsyncKVSetRaw(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::KVRemoveResponse>* AsyncKVRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status KVGet(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::uranium::api::KVGetResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVGetResponse>> AsyncKVGet(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVGetResponse>>(AsyncKVGetRaw(context, request, cq));
    }
    ::grpc::Status KVSet(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::uranium::api::KVSetResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVSetResponse>> AsyncKVSet(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVSetResponse>>(AsyncKVSetRaw(context, request, cq));
    }
    ::grpc::Status KVRemove(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::uranium::api::KVRemoveResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVRemoveResponse>> AsyncKVRemove(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::KVRemoveResponse>>(AsyncKVRemoveRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::KVGetResponse>* AsyncKVGetRaw(::grpc::ClientContext* context, const ::uranium::api::KVGetRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::KVSetResponse>* AsyncKVSetRaw(::grpc::ClientContext* context, const ::uranium::api::KVSetRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::KVRemoveResponse>* AsyncKVRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::KVRemoveRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_KVGet_;
    const ::grpc::RpcMethod rpcmethod_KVSet_;
    const ::grpc::RpcMethod rpcmethod_KVRemove_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // get the value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not yet exist.
    virtual ::grpc::Status KVGet(::grpc::ServerContext* context, const ::uranium::api::KVGetRequest* request, ::uranium::api::KVGetResponse* response);
    // set the value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status KVSet(::grpc::ServerContext* context, const ::uranium::api::KVSetRequest* request, ::uranium::api::KVSetResponse* response);
    // remove the value of a key, equal to set empty value of a key
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status KVRemove(::grpc::ServerContext* context, const ::uranium::api::KVRemoveRequest* request, ::uranium::api::KVRemoveResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_KVGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_KVGet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_KVGet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVGet(::grpc::ServerContext* context, const ::uranium::api::KVGetRequest* request, ::uranium::api::KVGetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKVGet(::grpc::ServerContext* context, ::uranium::api::KVGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::KVGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KVSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_KVSet() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_KVSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVSet(::grpc::ServerContext* context, const ::uranium::api::KVSetRequest* request, ::uranium::api::KVSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKVSet(::grpc::ServerContext* context, ::uranium::api::KVSetRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::KVSetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KVRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_KVRemove() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_KVRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVRemove(::grpc::ServerContext* context, const ::uranium::api::KVRemoveRequest* request, ::uranium::api::KVRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKVRemove(::grpc::ServerContext* context, ::uranium::api::KVRemoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::KVRemoveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_KVGet<WithAsyncMethod_KVSet<WithAsyncMethod_KVRemove<Service > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_KVGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_KVGet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_KVGet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVGet(::grpc::ServerContext* context, const ::uranium::api::KVGetRequest* request, ::uranium::api::KVGetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KVSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_KVSet() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_KVSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVSet(::grpc::ServerContext* context, const ::uranium::api::KVSetRequest* request, ::uranium::api::KVSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KVRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_KVRemove() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_KVRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KVRemove(::grpc::ServerContext* context, const ::uranium::api::KVRemoveRequest* request, ::uranium::api::KVRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
};

// //// interfaces for list data structure
class UraniumListService GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Insert all the specified values at the head of the list stored at key.
    // First the first value, then the second value, and one by one.
    // If key does not exist, it is created as empty list before performing the
    // push operations.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListLPush(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::uranium::api::ListLPushResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushResponse>> AsyncListLPush(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushResponse>>(AsyncListLPushRaw(context, request, cq));
    }
    // Removes and returns the first element of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListLPop(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::uranium::api::ListLPopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPopResponse>> AsyncListLPop(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPopResponse>>(AsyncListLPopRaw(context, request, cq));
    }
    // append one or multiple values to a list
    // insert all the specified values at the tail of the list stored at key.
    // If key does not exist, it is created as empty list before performing the
    // push operation.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListRPush(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::uranium::api::ListRPushResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushResponse>> AsyncListRPush(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushResponse>>(AsyncListRPushRaw(context, request, cq));
    }
    // Removes and returns the last element of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRPop(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::uranium::api::ListRPopResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPopResponse>> AsyncListRPop(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPopResponse>>(AsyncListRPopRaw(context, request, cq));
    }
    // Inserts value at the head of the list stored at key, only if key already
    // exists and holds a list. In contrary to ListLPush, no operation will be
    // performed when key does not yet exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListLPushX(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::uranium::api::ListLPushXResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushXResponse>> AsyncListLPushX(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushXResponse>>(AsyncListLPushXRaw(context, request, cq));
    }
    // Inserts value at the tail of the list stored at key, only if key already
    // exists and holds a list. In contrary to ListRPush, no operation will be
    // performed when key does not yet exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListRPushX(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::uranium::api::ListRPushXResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushXResponse>> AsyncListRPushX(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushXResponse>>(AsyncListRPushXRaw(context, request, cq));
    }
    // Returns the element at index index in the list stored at key. The index
    // is zero-based, so 0 means the first element, 1 the second element and
    // so on. Negative indices can be used to designate elements starting at the
    // tail of the list. Here, -1 means the last element, -2 means the penultimate
    // and so forth. When the value at key is not a list or index is out of range,
    // an error is returned.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    // OUT_OF_RANGE error is returned when index is out of range.
    virtual ::grpc::Status ListIndex(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::uranium::api::ListIndexResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListIndexResponse>> AsyncListIndex(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListIndexResponse>>(AsyncListIndexRaw(context, request, cq));
    }
    // Set the list element at index to value.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    // OUT_OF_RANGE error is return for out of range indexes.
    virtual ::grpc::Status ListSet(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::uranium::api::ListSetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListSetResponse>> AsyncListSet(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListSetResponse>>(AsyncListSetRaw(context, request, cq));
    }
    // Returns the specified elements of the list stored at key. The offsets start
    // and stop are zero-based indexes, with 0 being the first element of the
    // list (the head of the list), 1 being the next element and so on.
    // These offsets can also be negative numbers indicating offsets starting at
    // the end of the list. For example, -1 is the last element of the list,
    // -2 the penultimate, and so on.
    // Out of range indexes will not produce an error. If start is larger than
    // the end of the list, an empty list is returned. If stop is larger than
    // the actual end of the list, Redis will treat it like the last element of
    // the list.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRange(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::uranium::api::ListRangeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRangeResponse>> AsyncListRange(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRangeResponse>>(AsyncListRangeRaw(context, request, cq));
    }
    // Returns the length of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListLength(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::uranium::api::ListLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLengthResponse>> AsyncListLength(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLengthResponse>>(AsyncListLengthRaw(context, request, cq));
    }
    // Remove the whole list.
    // It will not produce an error if the key does not exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRemoveAll(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::uranium::api::ListRemoveAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRemoveAllResponse>> AsyncListRemoveAll(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRemoveAllResponse>>(AsyncListRemoveAllRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushResponse>* AsyncListLPushRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPopResponse>* AsyncListLPopRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushResponse>* AsyncListRPushRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPopResponse>* AsyncListRPopRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLPushXResponse>* AsyncListLPushXRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRPushXResponse>* AsyncListRPushXRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListIndexResponse>* AsyncListIndexRaw(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListSetResponse>* AsyncListSetRaw(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRangeResponse>* AsyncListRangeRaw(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListLengthResponse>* AsyncListLengthRaw(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::ListRemoveAllResponse>* AsyncListRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ListLPush(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::uranium::api::ListLPushResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushResponse>> AsyncListLPush(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushResponse>>(AsyncListLPushRaw(context, request, cq));
    }
    ::grpc::Status ListLPop(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::uranium::api::ListLPopResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPopResponse>> AsyncListLPop(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPopResponse>>(AsyncListLPopRaw(context, request, cq));
    }
    ::grpc::Status ListRPush(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::uranium::api::ListRPushResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushResponse>> AsyncListRPush(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushResponse>>(AsyncListRPushRaw(context, request, cq));
    }
    ::grpc::Status ListRPop(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::uranium::api::ListRPopResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPopResponse>> AsyncListRPop(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPopResponse>>(AsyncListRPopRaw(context, request, cq));
    }
    ::grpc::Status ListLPushX(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::uranium::api::ListLPushXResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushXResponse>> AsyncListLPushX(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushXResponse>>(AsyncListLPushXRaw(context, request, cq));
    }
    ::grpc::Status ListRPushX(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::uranium::api::ListRPushXResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushXResponse>> AsyncListRPushX(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushXResponse>>(AsyncListRPushXRaw(context, request, cq));
    }
    ::grpc::Status ListIndex(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::uranium::api::ListIndexResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListIndexResponse>> AsyncListIndex(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListIndexResponse>>(AsyncListIndexRaw(context, request, cq));
    }
    ::grpc::Status ListSet(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::uranium::api::ListSetResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListSetResponse>> AsyncListSet(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListSetResponse>>(AsyncListSetRaw(context, request, cq));
    }
    ::grpc::Status ListRange(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::uranium::api::ListRangeResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRangeResponse>> AsyncListRange(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRangeResponse>>(AsyncListRangeRaw(context, request, cq));
    }
    ::grpc::Status ListLength(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::uranium::api::ListLengthResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLengthResponse>> AsyncListLength(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLengthResponse>>(AsyncListLengthRaw(context, request, cq));
    }
    ::grpc::Status ListRemoveAll(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::uranium::api::ListRemoveAllResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRemoveAllResponse>> AsyncListRemoveAll(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRemoveAllResponse>>(AsyncListRemoveAllRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushResponse>* AsyncListLPushRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPushRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPopResponse>* AsyncListLPopRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPopRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushResponse>* AsyncListRPushRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPushRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPopResponse>* AsyncListRPopRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPopRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLPushXResponse>* AsyncListLPushXRaw(::grpc::ClientContext* context, const ::uranium::api::ListLPushXRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRPushXResponse>* AsyncListRPushXRaw(::grpc::ClientContext* context, const ::uranium::api::ListRPushXRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListIndexResponse>* AsyncListIndexRaw(::grpc::ClientContext* context, const ::uranium::api::ListIndexRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListSetResponse>* AsyncListSetRaw(::grpc::ClientContext* context, const ::uranium::api::ListSetRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRangeResponse>* AsyncListRangeRaw(::grpc::ClientContext* context, const ::uranium::api::ListRangeRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListLengthResponse>* AsyncListLengthRaw(::grpc::ClientContext* context, const ::uranium::api::ListLengthRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::ListRemoveAllResponse>* AsyncListRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::ListRemoveAllRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_ListLPush_;
    const ::grpc::RpcMethod rpcmethod_ListLPop_;
    const ::grpc::RpcMethod rpcmethod_ListRPush_;
    const ::grpc::RpcMethod rpcmethod_ListRPop_;
    const ::grpc::RpcMethod rpcmethod_ListLPushX_;
    const ::grpc::RpcMethod rpcmethod_ListRPushX_;
    const ::grpc::RpcMethod rpcmethod_ListIndex_;
    const ::grpc::RpcMethod rpcmethod_ListSet_;
    const ::grpc::RpcMethod rpcmethod_ListRange_;
    const ::grpc::RpcMethod rpcmethod_ListLength_;
    const ::grpc::RpcMethod rpcmethod_ListRemoveAll_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Insert all the specified values at the head of the list stored at key.
    // First the first value, then the second value, and one by one.
    // If key does not exist, it is created as empty list before performing the
    // push operations.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListLPush(::grpc::ServerContext* context, const ::uranium::api::ListLPushRequest* request, ::uranium::api::ListLPushResponse* response);
    // Removes and returns the first element of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListLPop(::grpc::ServerContext* context, const ::uranium::api::ListLPopRequest* request, ::uranium::api::ListLPopResponse* response);
    // append one or multiple values to a list
    // insert all the specified values at the tail of the list stored at key.
    // If key does not exist, it is created as empty list before performing the
    // push operation.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListRPush(::grpc::ServerContext* context, const ::uranium::api::ListRPushRequest* request, ::uranium::api::ListRPushResponse* response);
    // Removes and returns the last element of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRPop(::grpc::ServerContext* context, const ::uranium::api::ListRPopRequest* request, ::uranium::api::ListRPopResponse* response);
    // Inserts value at the head of the list stored at key, only if key already
    // exists and holds a list. In contrary to ListLPush, no operation will be
    // performed when key does not yet exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListLPushX(::grpc::ServerContext* context, const ::uranium::api::ListLPushXRequest* request, ::uranium::api::ListLPushXResponse* response);
    // Inserts value at the tail of the list stored at key, only if key already
    // exists and holds a list. In contrary to ListRPush, no operation will be
    // performed when key does not yet exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status ListRPushX(::grpc::ServerContext* context, const ::uranium::api::ListRPushXRequest* request, ::uranium::api::ListRPushXResponse* response);
    // Returns the element at index index in the list stored at key. The index
    // is zero-based, so 0 means the first element, 1 the second element and
    // so on. Negative indices can be used to designate elements starting at the
    // tail of the list. Here, -1 means the last element, -2 means the penultimate
    // and so forth. When the value at key is not a list or index is out of range,
    // an error is returned.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    // OUT_OF_RANGE error is returned when index is out of range.
    virtual ::grpc::Status ListIndex(::grpc::ServerContext* context, const ::uranium::api::ListIndexRequest* request, ::uranium::api::ListIndexResponse* response);
    // Set the list element at index to value.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    // OUT_OF_RANGE error is return for out of range indexes.
    virtual ::grpc::Status ListSet(::grpc::ServerContext* context, const ::uranium::api::ListSetRequest* request, ::uranium::api::ListSetResponse* response);
    // Returns the specified elements of the list stored at key. The offsets start
    // and stop are zero-based indexes, with 0 being the first element of the
    // list (the head of the list), 1 being the next element and so on.
    // These offsets can also be negative numbers indicating offsets starting at
    // the end of the list. For example, -1 is the last element of the list,
    // -2 the penultimate, and so on.
    // Out of range indexes will not produce an error. If start is larger than
    // the end of the list, an empty list is returned. If stop is larger than
    // the actual end of the list, Redis will treat it like the last element of
    // the list.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRange(::grpc::ServerContext* context, const ::uranium::api::ListRangeRequest* request, ::uranium::api::ListRangeResponse* response);
    // Returns the length of the list stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListLength(::grpc::ServerContext* context, const ::uranium::api::ListLengthRequest* request, ::uranium::api::ListLengthResponse* response);
    // Remove the whole list.
    // It will not produce an error if the key does not exist.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when key does not yet exist.
    virtual ::grpc::Status ListRemoveAll(::grpc::ServerContext* context, const ::uranium::api::ListRemoveAllRequest* request, ::uranium::api::ListRemoveAllResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLPush() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ListLPush() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPush(::grpc::ServerContext* context, const ::uranium::api::ListLPushRequest* request, ::uranium::api::ListLPushResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLPush(::grpc::ServerContext* context, ::uranium::api::ListLPushRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListLPushResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLPop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLPop() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ListLPop() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPop(::grpc::ServerContext* context, const ::uranium::api::ListLPopRequest* request, ::uranium::api::ListLPopResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLPop(::grpc::ServerContext* context, ::uranium::api::ListLPopRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListLPopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRPush() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ListRPush() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPush(::grpc::ServerContext* context, const ::uranium::api::ListRPushRequest* request, ::uranium::api::ListRPushResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRPush(::grpc::ServerContext* context, ::uranium::api::ListRPushRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListRPushResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRPop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRPop() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ListRPop() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPop(::grpc::ServerContext* context, const ::uranium::api::ListRPopRequest* request, ::uranium::api::ListRPopResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRPop(::grpc::ServerContext* context, ::uranium::api::ListRPopRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListRPopResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLPushX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLPushX() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ListLPushX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPushX(::grpc::ServerContext* context, const ::uranium::api::ListLPushXRequest* request, ::uranium::api::ListLPushXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLPushX(::grpc::ServerContext* context, ::uranium::api::ListLPushXRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListLPushXResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRPushX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRPushX() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListRPushX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPushX(::grpc::ServerContext* context, const ::uranium::api::ListRPushXRequest* request, ::uranium::api::ListRPushXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRPushX(::grpc::ServerContext* context, ::uranium::api::ListRPushXRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListRPushXResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListIndex() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ListIndex() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListIndex(::grpc::ServerContext* context, const ::uranium::api::ListIndexRequest* request, ::uranium::api::ListIndexResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListIndex(::grpc::ServerContext* context, ::uranium::api::ListIndexRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListIndexResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListSet() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ListSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSet(::grpc::ServerContext* context, const ::uranium::api::ListSetRequest* request, ::uranium::api::ListSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSet(::grpc::ServerContext* context, ::uranium::api::ListSetRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListSetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRange() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ListRange() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRange(::grpc::ServerContext* context, const ::uranium::api::ListRangeRequest* request, ::uranium::api::ListRangeResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRange(::grpc::ServerContext* context, ::uranium::api::ListRangeRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListRangeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListLength() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ListLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLength(::grpc::ServerContext* context, const ::uranium::api::ListLengthRequest* request, ::uranium::api::ListLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLength(::grpc::ServerContext* context, ::uranium::api::ListLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ListRemoveAll() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRemoveAll(::grpc::ServerContext* context, const ::uranium::api::ListRemoveAllRequest* request, ::uranium::api::ListRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListRemoveAll(::grpc::ServerContext* context, ::uranium::api::ListRemoveAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::ListRemoveAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ListLPush<WithAsyncMethod_ListLPop<WithAsyncMethod_ListRPush<WithAsyncMethod_ListRPop<WithAsyncMethod_ListLPushX<WithAsyncMethod_ListRPushX<WithAsyncMethod_ListIndex<WithAsyncMethod_ListSet<WithAsyncMethod_ListRange<WithAsyncMethod_ListLength<WithAsyncMethod_ListRemoveAll<Service > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_ListLPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLPush() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ListLPush() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPush(::grpc::ServerContext* context, const ::uranium::api::ListLPushRequest* request, ::uranium::api::ListLPushResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLPop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLPop() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ListLPop() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPop(::grpc::ServerContext* context, const ::uranium::api::ListLPopRequest* request, ::uranium::api::ListLPopResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRPush() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ListRPush() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPush(::grpc::ServerContext* context, const ::uranium::api::ListRPushRequest* request, ::uranium::api::ListRPushResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRPop : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRPop() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ListRPop() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPop(::grpc::ServerContext* context, const ::uranium::api::ListRPopRequest* request, ::uranium::api::ListRPopResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLPushX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLPushX() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ListLPushX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLPushX(::grpc::ServerContext* context, const ::uranium::api::ListLPushXRequest* request, ::uranium::api::ListLPushXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRPushX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRPushX() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListRPushX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRPushX(::grpc::ServerContext* context, const ::uranium::api::ListRPushXRequest* request, ::uranium::api::ListRPushXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListIndex : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListIndex() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ListIndex() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListIndex(::grpc::ServerContext* context, const ::uranium::api::ListIndexRequest* request, ::uranium::api::ListIndexResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListSet() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ListSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSet(::grpc::ServerContext* context, const ::uranium::api::ListSetRequest* request, ::uranium::api::ListSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRange() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ListRange() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRange(::grpc::ServerContext* context, const ::uranium::api::ListRangeRequest* request, ::uranium::api::ListRangeResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListLength() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ListLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLength(::grpc::ServerContext* context, const ::uranium::api::ListLengthRequest* request, ::uranium::api::ListLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ListRemoveAll() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListRemoveAll(::grpc::ServerContext* context, const ::uranium::api::ListRemoveAllRequest* request, ::uranium::api::ListRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
};

// //// interfaces for hash data structure
class UraniumHashService GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Returns the values associated with the specified fields in the hash stored
    // at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGet(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::uranium::api::HashGetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetResponse>> AsyncHashGet(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetResponse>>(AsyncHashGetRaw(context, request, cq));
    }
    // Returns all fields and values of the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAll(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::uranium::api::HashGetAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllResponse>> AsyncHashGetAll(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllResponse>>(AsyncHashGetAllRaw(context, request, cq));
    }
    // Returns all fields of the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAllFields(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::uranium::api::HashGetAllFieldsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllFieldsResponse>> AsyncHashGetAllFields(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllFieldsResponse>>(AsyncHashGetAllFieldsRaw(context, request, cq));
    }
    // Returns all values in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAllValues(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::uranium::api::HashGetAllValuesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllValuesResponse>> AsyncHashGetAllValues(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllValuesResponse>>(AsyncHashGetAllValuesRaw(context, request, cq));
    }
    // Returns the number of fields contained in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashLength(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::uranium::api::HashLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashLengthResponse>> AsyncHashLength(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashLengthResponse>>(AsyncHashLengthRaw(context, request, cq));
    }
    // Sets field in the hash stored at key to value. If key does not exist, a new
    // key holding a hash is created. If field already exists in the hash, it is
    // overwritten.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status HashSet(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::uranium::api::HashSetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetResponse>> AsyncHashSet(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetResponse>>(AsyncHashSetRaw(context, request, cq));
    }
    // Sets field in the hash stored at key to value, only if field does not yet
    // exist. If key does not exist, a new key holding a hash is created.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // FIELD_ALREADY_EXISTS error is returned when the field already exists.
    virtual ::grpc::Status HashSetX(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::uranium::api::HashSetXResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetXResponse>> AsyncHashSetX(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetXResponse>>(AsyncHashSetXRaw(context, request, cq));
    }
    // Removes the specified fields from the hash stored at key. Specified fields
    // that do not exist within this hash are ignored.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashRemove(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::uranium::api::HashRemoveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveResponse>> AsyncHashRemove(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveResponse>>(AsyncHashRemoveRaw(context, request, cq));
    }
    // Returns if field is an existing field in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashExists(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::uranium::api::HashExistsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashExistsResponse>> AsyncHashExists(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashExistsResponse>>(AsyncHashExistsRaw(context, request, cq));
    }
    // Remove the whole hash.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashRemoveAll(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::uranium::api::HashRemoveAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveAllResponse>> AsyncHashRemoveAll(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveAllResponse>>(AsyncHashRemoveAllRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetResponse>* AsyncHashGetRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllResponse>* AsyncHashGetAllRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllFieldsResponse>* AsyncHashGetAllFieldsRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashGetAllValuesResponse>* AsyncHashGetAllValuesRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashLengthResponse>* AsyncHashLengthRaw(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetResponse>* AsyncHashSetRaw(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashSetXResponse>* AsyncHashSetXRaw(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveResponse>* AsyncHashRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashExistsResponse>* AsyncHashExistsRaw(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::HashRemoveAllResponse>* AsyncHashRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status HashGet(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::uranium::api::HashGetResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetResponse>> AsyncHashGet(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetResponse>>(AsyncHashGetRaw(context, request, cq));
    }
    ::grpc::Status HashGetAll(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::uranium::api::HashGetAllResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllResponse>> AsyncHashGetAll(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllResponse>>(AsyncHashGetAllRaw(context, request, cq));
    }
    ::grpc::Status HashGetAllFields(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::uranium::api::HashGetAllFieldsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllFieldsResponse>> AsyncHashGetAllFields(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllFieldsResponse>>(AsyncHashGetAllFieldsRaw(context, request, cq));
    }
    ::grpc::Status HashGetAllValues(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::uranium::api::HashGetAllValuesResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllValuesResponse>> AsyncHashGetAllValues(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllValuesResponse>>(AsyncHashGetAllValuesRaw(context, request, cq));
    }
    ::grpc::Status HashLength(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::uranium::api::HashLengthResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashLengthResponse>> AsyncHashLength(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashLengthResponse>>(AsyncHashLengthRaw(context, request, cq));
    }
    ::grpc::Status HashSet(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::uranium::api::HashSetResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetResponse>> AsyncHashSet(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetResponse>>(AsyncHashSetRaw(context, request, cq));
    }
    ::grpc::Status HashSetX(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::uranium::api::HashSetXResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetXResponse>> AsyncHashSetX(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetXResponse>>(AsyncHashSetXRaw(context, request, cq));
    }
    ::grpc::Status HashRemove(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::uranium::api::HashRemoveResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveResponse>> AsyncHashRemove(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveResponse>>(AsyncHashRemoveRaw(context, request, cq));
    }
    ::grpc::Status HashExists(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::uranium::api::HashExistsResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashExistsResponse>> AsyncHashExists(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashExistsResponse>>(AsyncHashExistsRaw(context, request, cq));
    }
    ::grpc::Status HashRemoveAll(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::uranium::api::HashRemoveAllResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveAllResponse>> AsyncHashRemoveAll(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveAllResponse>>(AsyncHashRemoveAllRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetResponse>* AsyncHashGetRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllResponse>* AsyncHashGetAllRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllFieldsResponse>* AsyncHashGetAllFieldsRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllFieldsRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashGetAllValuesResponse>* AsyncHashGetAllValuesRaw(::grpc::ClientContext* context, const ::uranium::api::HashGetAllValuesRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashLengthResponse>* AsyncHashLengthRaw(::grpc::ClientContext* context, const ::uranium::api::HashLengthRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetResponse>* AsyncHashSetRaw(::grpc::ClientContext* context, const ::uranium::api::HashSetRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashSetXResponse>* AsyncHashSetXRaw(::grpc::ClientContext* context, const ::uranium::api::HashSetXRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveResponse>* AsyncHashRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::HashRemoveRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashExistsResponse>* AsyncHashExistsRaw(::grpc::ClientContext* context, const ::uranium::api::HashExistsRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::HashRemoveAllResponse>* AsyncHashRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::HashRemoveAllRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_HashGet_;
    const ::grpc::RpcMethod rpcmethod_HashGetAll_;
    const ::grpc::RpcMethod rpcmethod_HashGetAllFields_;
    const ::grpc::RpcMethod rpcmethod_HashGetAllValues_;
    const ::grpc::RpcMethod rpcmethod_HashLength_;
    const ::grpc::RpcMethod rpcmethod_HashSet_;
    const ::grpc::RpcMethod rpcmethod_HashSetX_;
    const ::grpc::RpcMethod rpcmethod_HashRemove_;
    const ::grpc::RpcMethod rpcmethod_HashExists_;
    const ::grpc::RpcMethod rpcmethod_HashRemoveAll_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Returns the values associated with the specified fields in the hash stored
    // at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGet(::grpc::ServerContext* context, const ::uranium::api::HashGetRequest* request, ::uranium::api::HashGetResponse* response);
    // Returns all fields and values of the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAll(::grpc::ServerContext* context, const ::uranium::api::HashGetAllRequest* request, ::uranium::api::HashGetAllResponse* response);
    // Returns all fields of the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAllFields(::grpc::ServerContext* context, const ::uranium::api::HashGetAllFieldsRequest* request, ::uranium::api::HashGetAllFieldsResponse* response);
    // Returns all values in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashGetAllValues(::grpc::ServerContext* context, const ::uranium::api::HashGetAllValuesRequest* request, ::uranium::api::HashGetAllValuesResponse* response);
    // Returns the number of fields contained in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the field does not yet exist.
    virtual ::grpc::Status HashLength(::grpc::ServerContext* context, const ::uranium::api::HashLengthRequest* request, ::uranium::api::HashLengthResponse* response);
    // Sets field in the hash stored at key to value. If key does not exist, a new
    // key holding a hash is created. If field already exists in the hash, it is
    // overwritten.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status HashSet(::grpc::ServerContext* context, const ::uranium::api::HashSetRequest* request, ::uranium::api::HashSetResponse* response);
    // Sets field in the hash stored at key to value, only if field does not yet
    // exist. If key does not exist, a new key holding a hash is created.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // FIELD_ALREADY_EXISTS error is returned when the field already exists.
    virtual ::grpc::Status HashSetX(::grpc::ServerContext* context, const ::uranium::api::HashSetXRequest* request, ::uranium::api::HashSetXResponse* response);
    // Removes the specified fields from the hash stored at key. Specified fields
    // that do not exist within this hash are ignored.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashRemove(::grpc::ServerContext* context, const ::uranium::api::HashRemoveRequest* request, ::uranium::api::HashRemoveResponse* response);
    // Returns if field is an existing field in the hash stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashExists(::grpc::ServerContext* context, const ::uranium::api::HashExistsRequest* request, ::uranium::api::HashExistsResponse* response);
    // Remove the whole hash.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status HashRemoveAll(::grpc::ServerContext* context, const ::uranium::api::HashRemoveAllRequest* request, ::uranium::api::HashRemoveAllResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_HashGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashGet() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_HashGet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGet(::grpc::ServerContext* context, const ::uranium::api::HashGetRequest* request, ::uranium::api::HashGetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashGet(::grpc::ServerContext* context, ::uranium::api::HashGetRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashGetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashGetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashGetAll() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_HashGetAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAll(::grpc::ServerContext* context, const ::uranium::api::HashGetAllRequest* request, ::uranium::api::HashGetAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashGetAll(::grpc::ServerContext* context, ::uranium::api::HashGetAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashGetAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashGetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashGetAllFields() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_HashGetAllFields() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAllFields(::grpc::ServerContext* context, const ::uranium::api::HashGetAllFieldsRequest* request, ::uranium::api::HashGetAllFieldsResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashGetAllFields(::grpc::ServerContext* context, ::uranium::api::HashGetAllFieldsRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashGetAllFieldsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashGetAllValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashGetAllValues() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_HashGetAllValues() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAllValues(::grpc::ServerContext* context, const ::uranium::api::HashGetAllValuesRequest* request, ::uranium::api::HashGetAllValuesResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashGetAllValues(::grpc::ServerContext* context, ::uranium::api::HashGetAllValuesRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashGetAllValuesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashLength() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_HashLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashLength(::grpc::ServerContext* context, const ::uranium::api::HashLengthRequest* request, ::uranium::api::HashLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashLength(::grpc::ServerContext* context, ::uranium::api::HashLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashSet() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_HashSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashSet(::grpc::ServerContext* context, const ::uranium::api::HashSetRequest* request, ::uranium::api::HashSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashSet(::grpc::ServerContext* context, ::uranium::api::HashSetRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashSetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashSetX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashSetX() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_HashSetX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashSetX(::grpc::ServerContext* context, const ::uranium::api::HashSetXRequest* request, ::uranium::api::HashSetXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashSetX(::grpc::ServerContext* context, ::uranium::api::HashSetXRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashSetXResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashRemove() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_HashRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRemove(::grpc::ServerContext* context, const ::uranium::api::HashRemoveRequest* request, ::uranium::api::HashRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashRemove(::grpc::ServerContext* context, ::uranium::api::HashRemoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashRemoveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashExists() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_HashExists() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashExists(::grpc::ServerContext* context, const ::uranium::api::HashExistsRequest* request, ::uranium::api::HashExistsResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashExists(::grpc::ServerContext* context, ::uranium::api::HashExistsRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashExistsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HashRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_HashRemoveAll() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_HashRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRemoveAll(::grpc::ServerContext* context, const ::uranium::api::HashRemoveAllRequest* request, ::uranium::api::HashRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHashRemoveAll(::grpc::ServerContext* context, ::uranium::api::HashRemoveAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::HashRemoveAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_HashGet<WithAsyncMethod_HashGetAll<WithAsyncMethod_HashGetAllFields<WithAsyncMethod_HashGetAllValues<WithAsyncMethod_HashLength<WithAsyncMethod_HashSet<WithAsyncMethod_HashSetX<WithAsyncMethod_HashRemove<WithAsyncMethod_HashExists<WithAsyncMethod_HashRemoveAll<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_HashGet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashGet() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_HashGet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGet(::grpc::ServerContext* context, const ::uranium::api::HashGetRequest* request, ::uranium::api::HashGetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashGetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashGetAll() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_HashGetAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAll(::grpc::ServerContext* context, const ::uranium::api::HashGetAllRequest* request, ::uranium::api::HashGetAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashGetAllFields : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashGetAllFields() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_HashGetAllFields() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAllFields(::grpc::ServerContext* context, const ::uranium::api::HashGetAllFieldsRequest* request, ::uranium::api::HashGetAllFieldsResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashGetAllValues : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashGetAllValues() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_HashGetAllValues() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashGetAllValues(::grpc::ServerContext* context, const ::uranium::api::HashGetAllValuesRequest* request, ::uranium::api::HashGetAllValuesResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashLength() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_HashLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashLength(::grpc::ServerContext* context, const ::uranium::api::HashLengthRequest* request, ::uranium::api::HashLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashSet : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashSet() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_HashSet() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashSet(::grpc::ServerContext* context, const ::uranium::api::HashSetRequest* request, ::uranium::api::HashSetResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashSetX : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashSetX() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_HashSetX() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashSetX(::grpc::ServerContext* context, const ::uranium::api::HashSetXRequest* request, ::uranium::api::HashSetXResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashRemove() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_HashRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRemove(::grpc::ServerContext* context, const ::uranium::api::HashRemoveRequest* request, ::uranium::api::HashRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashExists : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashExists() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_HashExists() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashExists(::grpc::ServerContext* context, const ::uranium::api::HashExistsRequest* request, ::uranium::api::HashExistsResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HashRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_HashRemoveAll() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_HashRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HashRemoveAll(::grpc::ServerContext* context, const ::uranium::api::HashRemoveAllRequest* request, ::uranium::api::HashRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
};

// //// interfaces for set data structure
class UraniumSetService GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Add the specified members to the set stored at key. Specified members that
    // are already a member of this set are ignored. If key does not exist, a new
    // set is created before adding the specified members.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status SetAdd(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::uranium::api::SetAddResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetAddResponse>> AsyncSetAdd(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetAddResponse>>(AsyncSetAddRaw(context, request, cq));
    }
    // Returns the set cardinality (number of elements) of the set stored at key.
    // If key does not exist, it is interpreted as an empty set and 0 is returned.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status SetLength(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::uranium::api::SetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetLengthResponse>> AsyncSetLength(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetLengthResponse>>(AsyncSetLengthRaw(context, request, cq));
    }
    // Returns if member is a member of the set stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetIsMember(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::uranium::api::SetIsMemberResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetIsMemberResponse>> AsyncSetIsMember(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetIsMemberResponse>>(AsyncSetIsMemberRaw(context, request, cq));
    }
    // Returns all the members of the set value stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetGetAll(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::uranium::api::SetGetAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetGetAllResponse>> AsyncSetGetAll(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetGetAllResponse>>(AsyncSetGetAllRaw(context, request, cq));
    }
    // Remove the specified members from the set stored at key. Specified members
    // that are not a member of this set are ignored.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetRemove(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::uranium::api::SetRemoveResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveResponse>> AsyncSetRemove(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveResponse>>(AsyncSetRemoveRaw(context, request, cq));
    }
    // Remove the whole set.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetRemoveAll(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::uranium::api::SetRemoveAllResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveAllResponse>> AsyncSetRemoveAll(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveAllResponse>>(AsyncSetRemoveAllRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetAddResponse>* AsyncSetAddRaw(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetLengthResponse>* AsyncSetLengthRaw(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetIsMemberResponse>* AsyncSetIsMemberRaw(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetGetAllResponse>* AsyncSetGetAllRaw(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveResponse>* AsyncSetRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::uranium::api::SetRemoveAllResponse>* AsyncSetRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status SetAdd(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::uranium::api::SetAddResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetAddResponse>> AsyncSetAdd(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetAddResponse>>(AsyncSetAddRaw(context, request, cq));
    }
    ::grpc::Status SetLength(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::uranium::api::SetLengthResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetLengthResponse>> AsyncSetLength(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetLengthResponse>>(AsyncSetLengthRaw(context, request, cq));
    }
    ::grpc::Status SetIsMember(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::uranium::api::SetIsMemberResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetIsMemberResponse>> AsyncSetIsMember(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetIsMemberResponse>>(AsyncSetIsMemberRaw(context, request, cq));
    }
    ::grpc::Status SetGetAll(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::uranium::api::SetGetAllResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetGetAllResponse>> AsyncSetGetAll(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetGetAllResponse>>(AsyncSetGetAllRaw(context, request, cq));
    }
    ::grpc::Status SetRemove(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::uranium::api::SetRemoveResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveResponse>> AsyncSetRemove(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveResponse>>(AsyncSetRemoveRaw(context, request, cq));
    }
    ::grpc::Status SetRemoveAll(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::uranium::api::SetRemoveAllResponse* response) GRPC_OVERRIDE;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveAllResponse>> AsyncSetRemoveAll(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveAllResponse>>(AsyncSetRemoveAllRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetAddResponse>* AsyncSetAddRaw(::grpc::ClientContext* context, const ::uranium::api::SetAddRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetLengthResponse>* AsyncSetLengthRaw(::grpc::ClientContext* context, const ::uranium::api::SetLengthRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetIsMemberResponse>* AsyncSetIsMemberRaw(::grpc::ClientContext* context, const ::uranium::api::SetIsMemberRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetGetAllResponse>* AsyncSetGetAllRaw(::grpc::ClientContext* context, const ::uranium::api::SetGetAllRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveResponse>* AsyncSetRemoveRaw(::grpc::ClientContext* context, const ::uranium::api::SetRemoveRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    ::grpc::ClientAsyncResponseReader< ::uranium::api::SetRemoveAllResponse>* AsyncSetRemoveAllRaw(::grpc::ClientContext* context, const ::uranium::api::SetRemoveAllRequest& request, ::grpc::CompletionQueue* cq) GRPC_OVERRIDE;
    const ::grpc::RpcMethod rpcmethod_SetAdd_;
    const ::grpc::RpcMethod rpcmethod_SetLength_;
    const ::grpc::RpcMethod rpcmethod_SetIsMember_;
    const ::grpc::RpcMethod rpcmethod_SetGetAll_;
    const ::grpc::RpcMethod rpcmethod_SetRemove_;
    const ::grpc::RpcMethod rpcmethod_SetRemoveAll_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Add the specified members to the set stored at key. Specified members that
    // are already a member of this set are ignored. If key does not exist, a new
    // set is created before adding the specified members.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status SetAdd(::grpc::ServerContext* context, const ::uranium::api::SetAddRequest* request, ::uranium::api::SetAddResponse* response);
    // Returns the set cardinality (number of elements) of the set stored at key.
    // If key does not exist, it is interpreted as an empty set and 0 is returned.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    virtual ::grpc::Status SetLength(::grpc::ServerContext* context, const ::uranium::api::SetLengthRequest* request, ::uranium::api::SetLengthResponse* response);
    // Returns if member is a member of the set stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetIsMember(::grpc::ServerContext* context, const ::uranium::api::SetIsMemberRequest* request, ::uranium::api::SetIsMemberResponse* response);
    // Returns all the members of the set value stored at key.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetGetAll(::grpc::ServerContext* context, const ::uranium::api::SetGetAllRequest* request, ::uranium::api::SetGetAllResponse* response);
    // Remove the specified members from the set stored at key. Specified members
    // that are not a member of this set are ignored.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetRemove(::grpc::ServerContext* context, const ::uranium::api::SetRemoveRequest* request, ::uranium::api::SetRemoveResponse* response);
    // Remove the whole set.
    // TABLE_NOT_FOUND error is returned when the table does not yet exist.
    // KEY_NOT_FOUND error is returned when the key does not exist.
    virtual ::grpc::Status SetRemoveAll(::grpc::ServerContext* context, const ::uranium::api::SetRemoveAllRequest* request, ::uranium::api::SetRemoveAllResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetAdd() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SetAdd() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAdd(::grpc::ServerContext* context, const ::uranium::api::SetAddRequest* request, ::uranium::api::SetAddResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAdd(::grpc::ServerContext* context, ::uranium::api::SetAddRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetAddResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetLength() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_SetLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLength(::grpc::ServerContext* context, const ::uranium::api::SetLengthRequest* request, ::uranium::api::SetLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetLength(::grpc::ServerContext* context, ::uranium::api::SetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetIsMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetIsMember() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetIsMember() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIsMember(::grpc::ServerContext* context, const ::uranium::api::SetIsMemberRequest* request, ::uranium::api::SetIsMemberResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetIsMember(::grpc::ServerContext* context, ::uranium::api::SetIsMemberRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetIsMemberResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetGetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetGetAll() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SetGetAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGetAll(::grpc::ServerContext* context, const ::uranium::api::SetGetAllRequest* request, ::uranium::api::SetGetAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetGetAll(::grpc::ServerContext* context, ::uranium::api::SetGetAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetGetAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetRemove() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_SetRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRemove(::grpc::ServerContext* context, const ::uranium::api::SetRemoveRequest* request, ::uranium::api::SetRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRemove(::grpc::ServerContext* context, ::uranium::api::SetRemoveRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetRemoveResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_SetRemoveAll() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRemoveAll(::grpc::ServerContext* context, const ::uranium::api::SetRemoveAllRequest* request, ::uranium::api::SetRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRemoveAll(::grpc::ServerContext* context, ::uranium::api::SetRemoveAllRequest* request, ::grpc::ServerAsyncResponseWriter< ::uranium::api::SetRemoveAllResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SetAdd<WithAsyncMethod_SetLength<WithAsyncMethod_SetIsMember<WithAsyncMethod_SetGetAll<WithAsyncMethod_SetRemove<WithAsyncMethod_SetRemoveAll<Service > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_SetAdd : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetAdd() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SetAdd() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAdd(::grpc::ServerContext* context, const ::uranium::api::SetAddRequest* request, ::uranium::api::SetAddResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetLength() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_SetLength() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetLength(::grpc::ServerContext* context, const ::uranium::api::SetLengthRequest* request, ::uranium::api::SetLengthResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetIsMember : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetIsMember() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetIsMember() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetIsMember(::grpc::ServerContext* context, const ::uranium::api::SetIsMemberRequest* request, ::uranium::api::SetIsMemberResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetGetAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetGetAll() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SetGetAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetGetAll(::grpc::ServerContext* context, const ::uranium::api::SetGetAllRequest* request, ::uranium::api::SetGetAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRemove : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetRemove() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_SetRemove() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRemove(::grpc::ServerContext* context, const ::uranium::api::SetRemoveRequest* request, ::uranium::api::SetRemoveResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRemoveAll : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_SetRemoveAll() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetRemoveAll() GRPC_OVERRIDE {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRemoveAll(::grpc::ServerContext* context, const ::uranium::api::SetRemoveAllRequest* request, ::uranium::api::SetRemoveAllResponse* response) GRPC_FINAL GRPC_OVERRIDE {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
};

class UraniumSchemaService GRPC_FINAL {
 public:
  class StubInterface {
   public:
    virtual ~StubInterface() {}
  private:
  };
  class Stub GRPC_FINAL : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
  };
  typedef Service AsyncService;
};
// TODO

}  // namespace api
}  // namespace uranium


#endif  // GRPC_uranium_2eproto__INCLUDED
